PLAYER, ENTITY = FindMetaTable( "Player" ), FindMetaTable( "Entity" )
:sub, :lower, :find, :match, :Trim = string
:LookupBone, :GetBonePosition = ENTITY
RunConsoleCommand = RunConsoleCommand
tonumber = tonumber
isnumber = isnumber
isvector = isvector
isangle = isangle
istable = istable
CurTime = CurTime
CLIENT = CLIENT
SERVER = SERVER
:Exists = file
:bor = bit

-- ULib support ( I really don't like this )
if Exists( "ulib/shared/hook.lua", "LUA" )
    include( "ulib/shared/hook.lua" )

PRE_HOOK = PRE_HOOK or HOOK_MONITOR_HIGH

addonName = "Unknown Taunts"

lib = uTaunt
unless istable( lib )
    lib = { Name: addonName }
    global uTaunt = lib

webSounds = list.GetForEdit( "uTaunt - WebSounds", false )
coopDances = list.GetForEdit( "uTaunt - Coop", false )

timer.Simple 0.5, ->
    for sequenceName, value in pairs( coopDances )
        if not isnumber( value ) or value < 1
            continue

        name, danceID = match( sequenceName, "^([%a_]+_?)(%d+)$" )
        if name == nil or danceID == nil
            continue

        danceID = tonumber( danceID )
        if danceID == nil
            continue

        for index = 1, value
            coopDances[ name .. ( danceID + index ) ] = 0

:IsValid, :GetNW2Var, :SetNW2Var, :LookupSequence, :SequenceDuration, :GetSequenceList, :IsDormant = ENTITY
:Add, :Run = hook
:Alive = PLAYER

ACT_GMOD_TAUNT_DANCE = ACT_GMOD_TAUNT_DANCE
GESTURE_SLOT_CUSTOM = GESTURE_SLOT_CUSTOM

isPlayingCTaunt = PLAYER.IsPlayingCTaunt
if isPlayingCTaunt == nil
    isPlayingCTaunt = PLAYER.IsPlayingTaunt
    PLAYER.IsPlayingCTaunt = isPlayingCTaunt

lib.GetSequenceName = ( ply ) ->
    return GetNW2Var( ply, "uTaunt-Name", "" )

getRenderAngles = nil
do

    :EyeAngles = ENTITY

    getRenderAngles = ( ply ) ->
        angles = EyeAngles( ply )
        angles[ 1 ], angles[ 3 ] = 0, 0
        return GetNW2Var( ply, "uTaunt-Angles", angles )

lib.GetRenderAngles = getRenderAngles

isPlayingTaunt = ( ply ) ->
    return GetNW2Var( ply, "uTaunt-Name" ) ~= nil

lib.IsPlayingTaunt = isPlayingTaunt

getStartTime = ( ply ) ->
    return GetNW2Var( ply, "uTaunt-Start" ) or CurTime!

lib.GetStartTime = getStartTime

lib.GetWebSound = ( sequenceName ) ->
    return webSounds[ sequenceName ]

lib.HasWebSound = ( sequenceName ) ->
    return webSounds[ sequenceName ] ~= nil

lib.HasWebSound = hasWebSound

findSound = nil
do

    sounds = list.GetForEdit( "uTaunt - Sounds", false )
    supportedExtensions = { "mp3", "wav", "ogg" }
    :GetTable = sound

    soundExists = ( sequenceName ) ->
        if Exists( "sound/unknown-taunts/" .. sequenceName, "GAME" )
            return true

        return false

    lib.SoundExists = soundExists

    findSound = ( sequenceName ) ->
        sequenceName = lower( sequenceName )

        if sounds[ sequenceName ]
            return sounds[ sequenceName ]

        for extension in *supportedExtensions
            if soundExists( sequenceName .. "." .. extension )
                return "unknown-taunts/" .. sequenceName .. "." .. extension

        sequenceName = "uTaunt." .. sequenceName
        for soundName in *GetTable!
            if soundName == sequenceName
                return soundName

    lib.FindSound = findSound

do

    isPlayingAnyTaunt = ( ply ) ->
        return ply.m_bIsPlayingTaunt

    PLAYER.IsPlayingTaunt = isPlayingAnyTaunt
    lib.IsPlayingAnyTaunt = isPlayingAnyTaunt

getCycle = nil
do

    :Clamp = math

    getCycle = ( ply, sequenceID, startTime ) ->
        return Clamp( ( CurTime! - ( startTime or getStartTime( ply ) ) ) / SequenceDuration( ply, sequenceID ), 0, 1 )

    lib.GetCycle = getCycle

do

    length, id, duration = 0, 0, 0

    lib.FindSequences = ( entity, pattern ) ->
        sequences, length = {}, 0

        for name in *GetSequenceList( entity )
            if find( name, pattern, 1, false ) == nil
                continue

            id = LookupSequence( entity, name )
            if id < 1
                continue

            duration = SequenceDuration( entity, id )
            if duration <= 0
                continue

            length += 1
            sequences[ length ] = { :id, :name, :duration }

        return sequences, length

isValidTauntingPlayer = ( ply ) ->
    return ply and IsValid( ply ) and Alive( ply ) and isPlayingTaunt( ply )

lib.IsValidTauntingPlayer = isValidTauntingPlayer

utaunt_allow_weapons, utaunt_allow_movement, utaunt_allow_attack = nil, nil, nil
do

    flags = bor( FCVAR_REPLICATED, FCVAR_ARCHIVE, FCVAR_NOTIFY )
    utaunt_allow_weapons = CreateConVar( "utaunt_allow_weapons", "0", flags, "Allow players to hold weapons in their hands while taunting.", 0, 1 )
    utaunt_allow_movement = CreateConVar( "utaunt_allow_movement", "0", flags, "Allow players to move while taunting.", 0, 1 )
    utaunt_allow_attack = CreateConVar( "utaunt_allow_attack", "0", flags, "Allow players to attack while taunting.", 0, 1 )

    utaunt_sound_override = CreateConVar( "utaunt_sound_override", "", flags, "Overrides the sound of all taunts to the specified one. Leave it blank so it won't be used." )

    Add "UnknownTauntSound", addonName .. "::SoundOverride", ->
        value = utaunt_sound_override\GetString!
        if #value == 0
            return

        if value == "0"
            return false

        return value

if SERVER

    resource.AddWorkshop( "3161527342" )
    :GetInfo = PLAYER

    lib.SetSequenceName = ( ply, sequenceName ) ->
        SetNW2Var( ply, "uTaunt-Name", sequenceName )

    lib.SetRenderAngles = ( ply, angles ) ->
        SetNW2Var( ply, "uTaunt-Angles", angles )

    lib.SetCycle = ( ply, cycle, sequenceID ) ->
        unless isnumber( cycle )
            cycle = 0

        unless isnumber( sequenceID )
            sequenceName = GetNW2Var( ply, "uTaunt-Name" )
            if sequenceName == nil
                return false

            sequenceID = LookupSequence( ply, sequenceName )

        if sequenceID < 1
            return false

        SetNW2Var( ply, "uTaunt-Start", CurTime! - ( cycle * SequenceDuration( ply, sequenceID ) ) )
        return true

    lib.IsAudioEnabled = ( ply ) ->
        return GetInfo( ply, "utaunt_audio" ) == "1"

    lib.IsCoopEnabled = ( ply ) ->
        return GetInfo( ply, "utaunt_coop" ) == "1"

    utaunt_menu_key, utaunt_real_origin, utaunt_coop_distance, utaunt_collisions = nil, nil, nil, nil
    do

        flags = bor( FCVAR_ARCHIVE, FCVAR_NOTIFY )
        utaunt_menu_key = CreateConVar( "utaunt_menu_key", KEY_I, flags, "Default key to open menu of unknown taunts, uses keys from https://wiki.facepunch.com/gmod/Enums/KEY", 0, 512 )
        utaunt_real_origin = CreateConVar( "utaunt_real_origin", "0", flags, "Uses the player's real position instead of initial position at the end of taunt.", 0, 1 )
        utaunt_coop_distance = CreateConVar( "utaunt_coop_distance", "512", flags, "Minimum required distance to join in a co-op taunt.", 0, 16384 )
        utaunt_collisions = CreateConVar( "utaunt_collisions", "0", flags, "Allow players to collide with each other while taunting.", 0, 1 )

    :GetModel, :SetCollisionGroup = ENTITY

    Add( "PlayerInitialSpawn", addonName .. "::CoopData", ( ply ) ->
        ply.m_tUnknownTauntPlayers = {}

    PRE_HOOK )

    do

        sequenceName, sequenceID, curTime, finishTime, timeRemaining = "", 0, 0, 0, 0
        isbool = isbool

        lib.Finish = ( ply, force ) ->
            sequenceName = GetNW2Var( ply, "uTaunt-Name" )
            if sequenceName == nil
                return false

            curTime, timeRemaining = CurTime!, 0
            finishTime = curTime

            sequenceID = LookupSequence( ply, sequenceName )
            if sequenceID > 0
                finishTime = getStartTime( ply ) + SequenceDuration( ply, sequenceID )

                timeRemaining = finishTime - curTime
                if timeRemaining < 0
                    timeRemaining = 0

            if not force and Run( "PlayerShouldFinishTaunt", ply, sequenceName, finishTime < curTime, timeRemaining, sequenceID, finishTime ) == false
                return false

            -- Origin
            origin = ply.m_vUnknownTauntOrigin
            if utaunt_real_origin\GetBool!
                leftFoot, rightFoot = LookupBone( ply, "ValveBiped.Bip01_L_Foot" ), LookupBone( ply, "ValveBiped.Bip01_R_Foot" )
                if leftFoot > 0 and rightFoot > 0
                    origin = ( GetBonePosition( ply, leftFoot ) + GetBonePosition( ply, rightFoot ) ) / 2
                else
                    origin = GetBonePosition( ply, 0 )

            if isvector( origin )
                ply\SetPos( origin )

            ply.m_vUnknownTauntOrigin = nil

            ply\AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
            SetNW2Var( ply, "uTaunt-Name", nil )
            ply\CrosshairEnable!

            -- Angles
            angles = GetNW2Var( ply, "uTaunt-Angles" )
            if isangle( angles )
                angles[ 1 ], angles[ 3 ] = 0, 0
                ply\SetEyeAngles( angles )

            SetNW2Var( ply, "uTaunt-Angles", nil )

            -- Coop players
            players = ply.m_tUnknownTauntPlayers
            for index = 1, #players
                otherPlayer = players[ index ]
                players[ index ] = nil

                if isValidTauntingPlayer( otherPlayer )
                    lib.Finish( otherPlayer, force )

            -- Collision group
            collisionGroup = ply.m_iUnknownTauntCollisionGroup
            if isnumber( collisionGroup )
                SetCollisionGroup( ply, collisionGroup )

            ply.m_iUnknownTauntCollisionGroup = nil

            -- Player pushing
            avoidPlayers = ply.m_bUnknownTauntAvoidPlayers
            if isbool( avoidPlayers )
                ply\SetAvoidPlayers( avoidPlayers )

            ply.m_bUnknownTauntAvoidPlayers = nil

            -- Weapon
            className = ply.m_sUnknownTauntWeapon
            if isstring( className )
                ply\SelectWeapon( className )

            ply.m_sUnknownTauntWeapon = nil

            -- Sound/Music
            cSound = ply.m_csUnknownTauntSound
            if cSound and cSound\IsPlaying!
                cSound\Stop!

            ply.m_csUnknownTauntSound = nil

            Run( "PlayerFinishedTaunt", ply, sequenceName, finishTime < curTime, timeRemaining, sequenceID, finishTime )
            return true

    forcedFinish = ( ply ) ->
        lib.Finish( ply, true )
        return

    Add "PlayerDisconnected", addonName .. "::Finish", forcedFinish, PRE_HOOK
    Add "PostPlayerDeath", addonName .. "::Finish", forcedFinish, PRE_HOOK
    Add "PlayerSpawn", addonName .. "::Finish", forcedFinish, PRE_HOOK

    Add "PlayerShouldTaunt", addonName .. "::DefaultTauntBlocking", ( ply, _, isUTaunt ) ->
        if not isUTaunt and isPlayingTaunt( ply )
            return false

    lib.Start = ( ply, sequenceName, force, cycle, noSound, startOrigin, startAngles ) ->
        if isPlayingCTaunt( ply )
            if isPlayingTaunt( ply )
                forcedFinish( ply )

            return false

        sequenceID = LookupSequence( ply, sequenceName )
        if sequenceID < 1
            return false

        unless force
            if Run( "PlayerShouldUnknownTaunt", ply, sequenceID ) ~= true or Run( "PlayerShouldTaunt", ply, ACT_GMOD_TAUNT_DANCE, true ) == false
                return false

            if GetInfo( ply, "utaunt_coop" ) == "1"
                maxDistance = utaunt_coop_distance\GetInt!
                if maxDistance > 0
                    for otherPlayer in *ents.FindInSphere( ply\GetPos!, maxDistance )
                        unless otherPlayer\IsPlayer! and Alive( otherPlayer )
                            continue

                        if otherPlayer == ply or GetNW2Var( otherPlayer, "uTaunt-Name" ) ~= sequenceName or GetInfo( otherPlayer, "utaunt_coop" ) ~= "1"
                            continue

                        if GetBonePosition( otherPlayer, 0 )\Distance( ply\EyePos! ) > maxDistance
                            continue

                        if Run( "PlayerShouldCoopTaunt", ply, otherPlayer, sequenceName ) == false
                            continue

                        if lib.Join( ply, otherPlayer )
                            return true

        duration = SequenceDuration( ply, sequenceID )
        if duration < 0.25
            return false

        if isPlayingTaunt( ply )
            forcedFinish( ply )

        ply.m_sUnknownTauntModel = GetModel( ply )

        if isvector( startOrigin )
            ply.m_vUnknownTauntOrigin = ply\GetPos!
            ply\SetPos( startOrigin )

        unless isangle( startAngles )
            startAngles = getRenderAngles( ply )

        SetNW2Var( ply, "uTaunt-Angles", startAngles )

        unless utaunt_collisions\GetBool!
            ply.m_iUnknownTauntCollisionGroup = ply\GetCollisionGroup!
            ply.m_bUnknownTauntAvoidPlayers = ply\GetAvoidPlayers!
            ply\SetAvoidPlayers( false )

        unless utaunt_allow_weapons\GetBool!
            weapon = ply\GetActiveWeapon!
            if weapon and IsValid( weapon )
                ply.m_sUnknownTauntWeapon = weapon\GetClass!
                ply\SetActiveWeapon!

        unless cycle
            cycle = 0

        SetNW2Var( ply, "uTaunt-Start", CurTime! - ( cycle * duration ) )
        SetNW2Var( ply, "uTaunt-Name", sequenceName )

        ply\AddVCDSequenceToGestureSlot( GESTURE_SLOT_CUSTOM, sequenceID, 0, true )
        ply\CrosshairDisable!

        if noSound or not ( GetInfo( ply, "utaunt_audio" ) == "1" or ply\IsBot! )
            SetNW2Var( ply, "uTaunt-WebAudio", false )

        elseif webSounds[ sequenceName ] ~= nil
            SetNW2Var( ply, "uTaunt-WebAudio", true )

        else

            soundPath = Run( "UnknownTauntSound", ply, sequenceName, cycle, duration, sequenceID )
            if soundPath == false
                SetNW2Var( ply, "uTaunt-WebAudio", false )

            else

                if soundPath == nil or soundPath == true
                    soundPath = findSound( sequenceName )

                if soundPath and find( soundPath, "^https?://.+$" ) == nil and not Exists( soundPath, "GAME" )
                    SetNW2Var( ply, "uTaunt-WebAudio", false )
                    cSound = CreateSound( ply, soundPath )
                    ply.m_csUnknownTauntSound = cSound
                    cSound\ChangeVolume( 0, 0 )
                    cSound\SetDSP( 1 )
                    cSound\Play!

                    cSound\ChangeVolume( 1, 1 )

                else

                    SetNW2Var( ply, "uTaunt-WebAudio", true )

        Run( "PlayerStartTaunt", ply, ACT_GMOD_TAUNT_DANCE, duration )
        Run( "PlayerStartedUnknownTaunt", ply, sequenceName, duration )
        return true

    lib.Join = ( ply, otherPlayer ) ->
        sequenceName = GetNW2Var( otherPlayer, "uTaunt-Name" )
        if sequenceName == nil
            return false

        sequenceID = LookupSequence( ply, sequenceName )
        if sequenceID < 1
            return false

        players = otherPlayer.m_tUnknownTauntPlayers
        if not isnumber( coopDances[ sequenceName ] ) or coopDances[ sequenceName ] < 1
            players[] = ply
            return lib.Start( ply, sequenceName, true, getCycle( otherPlayer, sequenceID ), true )

        danceName, danceID = match( sequenceName, "^([%a_]+_?)(%d+)$" )
        if danceName == nil or danceID == nil
            return false

        danceID = tonumber( danceID )
        if danceID == nil
            return false

        for index = 1, coopDances[ sequenceName ]
            if not isValidTauntingPlayer( players[ index ] ) or players[ index ] == ply
                players[ index ] = ply
                return lib.Start( ply, danceName .. ( danceID + index ), true, getCycle( otherPlayer, sequenceID ), true, otherPlayer\GetPos!, getRenderAngles( otherPlayer ) )

        return false

    do

        COLLISION_GROUP_PASSABLE_DOOR = COLLISION_GROUP_PASSABLE_DOOR
        :GetCollisionGroup = ENTITY
        :Crouching = PLAYER
        sequenceID = 0

        Add( "PlayerTauntThink", addonName .. "::Thinking", ( ply, isUTaunt ) ->
            unless isUTaunt
                return

            if not Alive( ply ) or Crouching( ply )
                forcedFinish( ply )
                return

            sequenceName = GetNW2Var( ply, "uTaunt-Name" )
            if sequenceName == nil
                return

            sequenceID = LookupSequence( ply, sequenceName )
            if sequenceID < 1
                forcedFinish( ply )
                return

            if GetModel( ply ) ~= ply.m_sUnknownTauntModel
                forcedFinish( ply )
                return

            cycle = getCycle( ply, sequenceID )
            if Run( "UnknownTauntThink", ply, sequenceName, cycle, sequenceID ) == false or cycle == 1
                lib.Finish( ply, false )
                return

            if utaunt_collisions\GetBool!
                return

            if GetCollisionGroup( ply ) == COLLISION_GROUP_PASSABLE_DOOR
                return

            SetCollisionGroup( ply, COLLISION_GROUP_PASSABLE_DOOR )
            return

        PRE_HOOK )

    concommand.Add "utaunt", ( ply, _, args ) ->
        if not ( ply and IsValid( ply ) and Alive( ply ) ) or isPlayingCTaunt( ply )
            return

        if isstring( args[ 1 ] )
            lib.Start( ply, args[ 1 ], false )
            return

    concommand.Add "utaunt_stop", ( ply ) ->
        if isPlayingTaunt( ply )
            lib.Finish( ply, false )

    do

        :GetSequenceActivity = ENTITY

        acts = {
            [ ACT_GMOD_TAUNT_DANCE ]: true
            [ ACT_GMOD_TAUNT_ROBOT ]: true
            [ ACT_GMOD_TAUNT_CHEER ]: true
            [ ACT_GMOD_TAUNT_LAUGH ]: true
            [ ACT_GMOD_TAUNT_SALUTE ]: true
            [ ACT_GMOD_TAUNT_MUSCLE ]: true
            [ ACT_GMOD_TAUNT_PERSISTENCE ]: true

            [ ACT_GMOD_GESTURE_BOW ]: true
            [ ACT_GMOD_GESTURE_WAVE ]: true
            [ ACT_GMOD_GESTURE_AGREE ]: true
            [ ACT_GMOD_GESTURE_BECON ]: true
            [ ACT_GMOD_GESTURE_DISAGREE ]: true

            [ ACT_GMOD_GESTURE_RANGE_ZOMBIE ]: true
            [ ACT_GMOD_GESTURE_TAUNT_ZOMBIE ]: true
            [ ACT_GMOD_GESTURE_RANGE_ZOMBIE_SPECIAL ]: true

            [ ACT_GMOD_GESTURE_ITEM_GIVE ]: true
            [ ACT_GMOD_GESTURE_ITEM_DROP ]: true
            [ ACT_GMOD_GESTURE_ITEM_PLACE ]: true
            [ ACT_GMOD_GESTURE_ITEM_THROW ]: true

            [ ACT_SIGNAL_FORWARD ]: true
            [ ACT_SIGNAL_GROUP ]: true
            [ ACT_SIGNAL_HALT ]: true
        }

        Add "PlayerShouldUnknownTaunt", addonName .. "::DefaultSequences", ( ply, sequenceID ) ->
            if acts[ GetSequenceActivity( ply, sequenceID ) ]
                return true

    Add( "PlayerFinishedTaunt", addonName .. "::TauntLooping", ( ply, sequenceName, isFinished ) ->
        if isFinished and GetInfo( ply, "utaunt_loop" ) == "1"
            lib.Start( ply, sequenceName, false )

    PRE_HOOK )

    Add( "PlayerButtonDown", addonName .. "::TauntMenu", ( ply, keyCode ) ->
        if keyCode == utaunt_menu_key\GetInt!
            ply\ConCommand( "utaunts " .. keyCode )
            return

    PRE_HOOK )

Add "PlayerSwitchWeapon", addonName .. "::WeaponSwitch", ( ply ) ->
    if ply.m_bIsPlayingTaunt
        if utaunt_allow_weapons\GetBool!
            return

        return true

do

    :Iterator = player
    curTime = 0

    Add( "Think", addonName .. "::IsPlayingTaunt", ->
        curTime = CurTime!
        for _, ply in Iterator!
            unless IsDormant( ply )
                if isPlayingTaunt( ply )
                    ply.m_dLastPlayingTaunt = curTime
                    Run( "PlayerTauntThink", ply, true )

                elseif isPlayingCTaunt( ply )
                    ply.m_dLastPlayingTaunt = curTime
                    Run( "PlayerTauntThink", ply, false )

            if ply.m_dLastPlayingTaunt == nil
                if ply.m_bIsPlayingTaunt == nil
                    ply.m_bIsPlayingTaunt = false

                continue

            if ( curTime - ply.m_dLastPlayingTaunt ) > 0.1
                ply.m_dLastPlayingTaunt = nil
                ply.m_bIsPlayingTaunt = false
                continue

            ply.m_bIsPlayingTaunt = true
            return

    PRE_HOOK )

do

    :SetRenderAngles = PLAYER

    Add( "UpdateAnimation", addonName .. "::RenderAngles", ( ply ) ->
        if isPlayingTaunt( ply )
            SetRenderAngles( ply, getRenderAngles( ply ) )
            return

    PRE_HOOK )

do

    :ClearMovement, :SetButtons, :SetImpulse, :KeyDown, :RemoveKey = FindMetaTable( "CUserCmd" )
    IN_ATTACK, IN_ATTACK2, IN_DUCK, IN_JUMP = IN_ATTACK, IN_ATTACK2, IN_DUCK, IN_JUMP
    :band = bit

    buttons = 0

    Add( "StartCommand", addonName .. "::Movement", ( ply, cmd ) ->
        unless ply.m_bIsPlayingTaunt
            return

        buttons = Run( "TauntStartCommand", ply, cmd, GetNW2Var( ply, "uTaunt-Name", "" ) )
        unless isnumber( buttons )
            buttons = 0

        if KeyDown( cmd, IN_JUMP )
            RemoveKey( cmd, IN_JUMP )

            if isPlayingTaunt( ply ) and CLIENT and ply.m_bIsLocalPlayer
                RunConsoleCommand( "utaunt_stop" )

        if KeyDown( cmd, IN_DUCK )
            RemoveKey( cmd, IN_DUCK )

        unless utaunt_allow_movement\GetBool!
            ClearMovement( cmd )

        if utaunt_allow_attack\GetBool!
            if KeyDown( cmd, IN_ATTACK ) and band( buttons, IN_ATTACK ) == 0
                buttons = bor( buttons, IN_ATTACK )

            if KeyDown( cmd, IN_ATTACK2 ) and band( buttons, IN_ATTACK2 ) == 0
                buttons = bor( buttons, IN_ATTACK2 )

        SetButtons( cmd, buttons )
        SetImpulse( cmd, 0 )
        return

    PRE_HOOK )

unless CLIENT
    return

CreateClientConVar( "utaunt_loop", "0", true, true, "Enables looping for all taunts.", 0, 1 )

do

    utaunt_audio = CreateClientConVar( "utaunt_audio", "1", true, true, "Enables audio playback for taunts that support this feature.", 0, 1 )

    lib.IsAudioEnabled = ->
        return utaunt_audio\GetBool!

do

    utaunt_coop = CreateClientConVar( "utaunt_coop", "1", true, true, "If enabled player will automatically join/synchronize with dance of another player nearby.", 0, 1 )

    lib.IsCoopEnabled = ->
        return utaunt_coop\GetBool!

:GetPhrase = language

getPhrase = ( placeholder ) ->
    fulltext = GetPhrase( placeholder )
    if fulltext == placeholder and sub( placeholder, 1, 15 ) == "unknown_taunts."
        return GetPhrase( sub( placeholder, 16 ) )

    return fulltext

lib.GetPhrase = getPhrase

do

    ply = LocalPlayer!
    isInTaunt = false

    global IsInTaunt = ->
        return isInTaunt

    Add( "InitPostEntity", addonName .. "::Initialization", ->
        ply = LocalPlayer!
        ply.m_bIsLocalPlayer = true
        ply.m_bIsPlayingTaunt = false

    PRE_HOOK )

    Add( "Think", addonName .. "::IsInTaunt", ->
        if ply and IsValid( ply )
            isInTaunt = ply.m_bIsPlayingTaunt

    PRE_HOOK )

    Add "HUDShouldDraw", addonName .. "::WeaponSelector", ( name ) ->
        if isInTaunt and name == "CHudWeaponSelection" and not utaunt_allow_weapons\GetBool!
            return false

do

    mins, maxs = Vector( -512, -512, 0 ), Vector( 512, 512, 512 )
    :Forward = FindMetaTable( "Angle" )

    stopAudio = ( ply ) ->
        channel = ply.m_bcUnknownTauntAudio
        if channel and channel\IsValid!
            channel\Stop!

        ply.m_bcUnknownTauntAudio = nil

    playStates = {
        [ GMOD_CHANNEL_PLAYING ]: true
        [ GMOD_CHANNEL_STALLED ]: true
    }

    :Remove = hook
    boneID = 0

    Add( "UnknownTauntSynced", addonName .. "::Sync", ( ply, sequenceName, cycle, sequenceID, webAudio ) ->
        mins[ 3 ] = ply\GetModelRenderBounds![ 3 ]
        ply\SetRenderBounds( mins, maxs )

        if not webAudio or IsDormant( ply )
            stopAudio( ply )
            return

        filePath = Run( "UnknownTauntSound", ply, sequenceName, cycle, SequenceDuration( ply, sequenceID ) or 0, sequenceID ) or webSounds[ sequenceName ]

        channel = ply.m_bcUnknownTauntAudio
        if channel and channel\IsValid!
            unless filePath
                ply.m_sUnknownTauntAudioFilePath = nil
                ply.m_bcUnknownTauntAudio = nil
                channel\Stop!
                return

            if filePath == ply.m_sUnknownTauntAudioFilePath
                length = channel\GetLength!
                if length > 0
                    channel\SetTime( length * cycle )

                unless playStates[ channel\GetState! ]
                    channel\Play!

                return

            ply.m_sUnknownTauntAudioFilePath = nil
            ply.m_bcUnknownTauntAudio = nil
            channel\Stop!

        unless filePath
            return

        isURL = find( filePath, "^https?://.+$" ) ~= nil
        unless isURL or Exists( filePath, "GAME" )
            return

        sound[ isURL and "PlayURL" or "PlayFile" ] filePath, "3d noplay noblock", ( newChannel ) ->
            unless newChannel and newChannel\IsValid! and isValidTauntingPlayer( ply ) and not IsDormant( ply )
                return

            ply.m_sUnknownTauntAudioFilePath = filePath
            ply.m_bcUnknownTauntAudio = newChannel

            length = newChannel\GetLength!
            if length > 0
                newChannel\SetTime( length * cycle )

            newChannel\Play!

            Add "Think", newChannel, ->
                if not isValidTauntingPlayer( ply ) or IsDormant( ply )
                    Remove( "Think", newChannel )

                    if IsValid( ply )
                        ply.m_sUnknownTauntAudioFilePath = nil
                        ply.m_bcUnknownTauntAudio = nil

                    newChannel\Stop!
                    return

                boneID = LookupBone( ply, "ValveBiped.Bip01_Head1" )
                if boneID and boneID >= 0
                    newChannel\SetPos( GetBonePosition( ply, boneID ), Forward( getRenderAngles( ply ) ) )
                    return

                newChannel\SetPos( ply\WorldSpaceCenter!, Forward( getRenderAngles( ply ) ) )
                return

            return

        return
    PRE_HOOK )

    Add( "PlayerFinishedTaunt", addonName .. "::Cleanup", ( ply ) ->
        ply\SetRenderBounds( ply\GetModelRenderBounds! )
        stopAudio( ply )
        return

    PRE_HOOK )

do

    cycle = 0

    Add( "EntityNetworkedVarChanged", addonName .. "::Networking", ( ply, key, oldValue, value ) ->
        unless IsValid( ply ) and ply\IsPlayer! and Alive( ply )
            return

        if key == "uTaunt-Name"
            if value == nil
                if ply.m_bUsingUnknownTaunt
                    ply.m_bUsingUnknownTaunt = false
                    ply\AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
                    Run( "PlayerFinishedTaunt", ply, oldValue )

                return

            sequenceID = LookupSequence( ply, value )
            if sequenceID < 1
                return

            ply.m_bUsingUnknownTaunt = true

            cycle = getCycle( ply, sequenceID )
            ply\AddVCDSequenceToGestureSlot( GESTURE_SLOT_CUSTOM, sequenceID, cycle, true )
            Run( "UnknownTauntSynced", ply, value, cycle, sequenceID, GetNW2Var( ply, "uTaunt-WebAudio", false ) )
            return

        if key == "uTaunt-Start"
            sequenceName = GetNW2Var( ply, "uTaunt-Name" )
            if sequenceName == nil
                if ply.m_bUsingUnknownTaunt
                    ply.m_bUsingUnknownTaunt = false
                    ply\AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
                    Run( "PlayerFinishedTaunt", ply, sequenceName )

                return

            sequenceID = LookupSequence( ply, sequenceName )
            if sequenceID < 1
                return

            ply.m_bUsingUnknownTaunt = true

            cycle = getCycle( ply, sequenceID, value )
            ply\AddVCDSequenceToGestureSlot( GESTURE_SLOT_CUSTOM, sequenceID, cycle, true )
            Run( "UnknownTauntSynced", ply, sequenceName, cycle, sequenceID, GetNW2Var( ply, "uTaunt-WebAudio", false ) )
            return

        if key == "uTaunt-WebAudio"
            sequenceName = GetNW2Var( ply, "uTaunt-Name" )
            if sequenceName == nil
                if ply.m_bUsingUnknownTaunt
                    ply.m_bUsingUnknownTaunt = false
                    ply\AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
                    Run( "PlayerFinishedTaunt", ply, sequenceName )

                return

            sequenceID = LookupSequence( ply, sequenceName )
            if sequenceID < 1
                return

            ply.m_bUsingUnknownTaunt = true

            cycle = getCycle( ply, sequenceID )
            ply\AddVCDSequenceToGestureSlot( GESTURE_SLOT_CUSTOM, sequenceID, cycle, true )
            Run( "UnknownTauntSynced", ply, sequenceName, cycle, sequenceID, value == true )
            return

    PRE_HOOK )

    Add( "NotifyShouldTransmit", addonName .. "::PVS", ( ply, shouldtransmit ) ->
        unless shouldtransmit and IsValid( ply ) and ply\IsPlayer! and Alive( ply )
            if ply.m_bUsingUnknownTaunt
                ply.m_bUsingUnknownTaunt = false
                ply\AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
                Run( "PlayerFinishedTaunt", ply, oldValue )

            return

        sequenceName = GetNW2Var( ply, "uTaunt-Name" )
        if sequenceName == nil
            if ply.m_bUsingUnknownTaunt
                ply.m_bUsingUnknownTaunt = false
                ply\AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
                Run( "PlayerFinishedTaunt", ply, oldValue )

            return

        sequenceID = LookupSequence( ply, sequenceName )
        if sequenceID < 1
            return

        ply.m_bUsingUnknownTaunt = true

        cycle = getCycle( ply, sequenceID )
        ply\AddVCDSequenceToGestureSlot( GESTURE_SLOT_CUSTOM, sequenceID, cycle, true )
        Run( "UnknownTauntSynced", ply, sequenceName, cycle, sequenceID )
        return

    PRE_HOOK )

toggleMenu = ( ply, keyCode ) ->
    if isPlayingCTaunt( ply )
        return false

    if keyCode ~= nil
        bind = input.LookupKeyBinding( keyCode )
        if bind ~= nil and #bind > 0
            return false

    panel = lib.Panel
    if panel and panel\IsValid!
        panel\Remove!
        return true

    if Run( "AllowTauntMenu", ply ) == false
        return false

    panel = vgui.Create( "uTaunt::Menu" )
    lib.Panel = panel
    panel\Setup( ply )
    return true

lib.ToggleMenu = toggleMenu

concommand.Add "utaunts", ( ply, _, args ) ->
    unless ply\Alive!
        return

    keyCode = args[ 1 ]
    if keyCode ~= nil and #keyCode > 0
        keyCode = tonumber( keyCode )

    toggleMenu( ply, keyCode )
    return

do

    commmands = { "taunt", "dance", "utaunt", "udance" }
    allowedChars = { "/": true, "!": true }

    Add "OnPlayerChat", addonName .. "::ChatCommands", ( ply, text, isTeam, isDead ) ->
        if isDead or isTeam or not ply.m_bIsLocalPlayer
            return

        text = lower( Trim( text ) )

        if allowedChars[ sub( text, 1, 1 ) ] == nil
            return

        text = sub( text, 2 )

        for command in *commmands
            if find( text, command, 1, false ) ~= nil
                toggleMenu( ply )
                return true

-- Default Sequences
do

    :format = string

    taunts = {
        "taunt_cheer"
        "taunt_dance"
        "taunt_laugh"
        "taunt_muscle"
        "taunt_robot"
        "taunt_persistence"
        "taunt_zombie"
    }

    gestures = {
        "gesture_agree"
        "gesture_bow"
        "gesture_becon"
        "gesture_disagree"
        "gesture_salute"
        "gesture_wave"

        "gesture_item_drop"
        "gesture_item_give"
        "gesture_item_place"
        "gesture_item_throw"

        "gesture_signal_forward"
        "gesture_signal_halt"
        "gesture_signal_group"
    }

    zombie = {
        "zombie_attack_01"
        "zombie_attack_02"
        "zombie_attack_03"
        "zombie_attack_04"
        "zombie_attack_05"
        "zombie_attack_06"
        "zombie_attack_07"
        "zombie_attack_special"
    }

    Add "UnknownTauntMenuSetup", addonName .. "::DefaultSequences", ( ply, add ) ->
        sequences, sequencesCount = {}, 0
        for sequenceName in *taunts
            if LookupSequence( ply, sequenceName ) < 0
                continue

            sequencesCount += 1
            sequences[ sequencesCount ] = sequenceName

        if sequencesCount > 0
            add( format( GetPhrase( "unknown_taunts.menu.taunts" ), "Garry's Mod" ), sequences )

            for index = 1, sequencesCount
                sequences[ index ] = nil

            sequencesCount = 0

        for sequenceName in *gestures
            if LookupSequence( ply, sequenceName ) < 0
                continue

            sequencesCount += 1
            sequences[ sequencesCount ] = sequenceName

        if sequencesCount > 0
            add( format( GetPhrase( "unknown_taunts.menu.gestures" ), "Garry's Mod" ), sequences )

            for index = 1, sequencesCount
                sequences[ index ] = nil

            sequencesCount = 0

        for sequenceName in *zombie
            if LookupSequence( ply, sequenceName ) < 0
                continue

            sequencesCount += 1
            sequences[ sequencesCount ] = sequenceName

        if sequencesCount > 0
            add( format( GetPhrase( "unknown_taunts.menu.zombie" ), "Garry's Mod" ), sequences )

        return

do

    utaunt_menu_auto_close = CreateClientConVar( "utaunt_menu_auto_close", "0", true, false, "Automatically close the taunt menu when a taunt is selected.", 0, 1 )
    :DrawRect, :SetDrawColor = surface
    :floor, :Round = math

    PANEL = {}

    PANEL.Init = =>
        @SetTitle( "#unknown_taunts.menu.title" )
        @SetSize( ScreenScale( 128 ), 24 )
        @SetIcon( "icon16/user.png" )
        @MakePopup!
        @Center!

    PANEL.ClickSound = ->
        surface.PlaySound( "garrysmod/ui_click.wav" )

    PANEL.Setup = ( ply ) =>
        scrollPanel = @Add( "DScrollPanel" )
        @ScrollPanel = scrollPanel
        scrollPanel\Dock( FILL )

        scrollPanel.PerformLayout = ( _, width, height ) ->
            canvas = scrollPanel\GetCanvas!
            if canvas and canvas\IsValid!
                margin = ScreenScale( 2 )
                canvas\DockPadding( margin, 0, margin, margin )

            DScrollPanel.PerformLayout( scrollPanel, width, height )

        actions = scrollPanel\Add( "EditablePanel" )
        actions.Progress = 0
        actions\Dock( TOP )

        actions.PerformLayout = ->
            actions\SetTall( 32 )

        actions.Think = ->
            sequenceName = GetNW2Var( ply, "uTaunt-Name" )
            if sequenceName == nil
                actions.Progress = 0
                return

            sequenceID = LookupSequence( ply, sequenceName )
            if sequenceID < 1
                actions.Progress = 0
                return

            actions.Progress = getCycle( ply, sequenceID )

        actions.Paint = ( _, width, height ) ->
            SetDrawColor( 150, 255, 50, 220 )
            DrawRect( 0, height - 2, width * actions.Progress, 2 )

        do

            button = actions\Add( "DButton" )
            button\SetText( "" )
            button\SetWide( 32 )
            button\Dock( RIGHT )
            button.Paint = ->

            button.UpdateIcon = ( state ) ->
                button\SetImage( state and "icon16/group.png" or "icon16/user.png" )

            button.UpdateIcon( cvars.Bool( "utaunt_coop" ) )

            button.DoClick = ->
                if cvars.Bool( "utaunt_coop" )
                    RunConsoleCommand( "utaunt_coop", "0" )
                    button.UpdateIcon( false )
                else
                    RunConsoleCommand( "utaunt_coop", "1" )
                    button.UpdateIcon( true )

                @ClickSound!

        do

            button = actions\Add( "DButton" )
            button\SetText( "" )
            button\SetWide( 32 )
            button\Dock( RIGHT )
            button.Paint = ->

            button.UpdateIcon = ( state ) ->
                button\SetImage( state and "icon16/sound.png" or "icon16/sound_mute.png" )

            button.UpdateIcon( cvars.Bool( "utaunt_audio" ) )

            button.DoClick = ->
                if cvars.Bool( "utaunt_audio" )
                    RunConsoleCommand( "utaunt_audio", "0" )
                    button.UpdateIcon( false )
                else
                    RunConsoleCommand( "utaunt_audio", "1" )
                    button.UpdateIcon( true )

                @ClickSound!

        do

            button = actions\Add( "DButton" )
            button\SetText( "" )
            button\SetWide( 32 )
            button\Dock( RIGHT )
            button.Paint = ->

            button.UpdateIcon = ( state ) ->
                button\SetImage( state and "icon16/control_repeat_blue.png" or "icon16/control_repeat.png" )

            button.UpdateIcon( cvars.Bool( "utaunt_loop" ) )

            button.DoClick = ->
                if cvars.Bool( "utaunt_loop" )
                    RunConsoleCommand( "utaunt_loop", "0" )
                    button.UpdateIcon( false )
                else
                    RunConsoleCommand( "utaunt_loop", "1" )
                    button.UpdateIcon( true )

                @ClickSound!

        do

            button = actions\Add( "DButton" )
            button\SetText( "" )
            button\SetWide( 32 )
            button\Dock( RIGHT )
            button.Paint = ->

            button.Think = ->
                state = isPlayingTaunt( ply )
                if button.State ~= state
                    button.State = state

                    if state
                        button\SetImage( "icon16/control_stop_blue.png" )
                    else
                        button\SetImage( "icon16/control_stop.png" )

            button.DoClick = ->
                if isPlayingTaunt( ply )
                    RunConsoleCommand( "utaunt_stop" )
                    @ClickSound!

        do

            label = actions\Add( "DLabel" )
            label.SequenceName = ""
            label\Dock( FILL )

            label.Think = ->
                unless isPlayingTaunt( ply )
                    if label.SequenceName ~= nil
                        label.SequenceName = nil
                        label\SetText( "#unknown_taunts.menu.none" )

                    return

                sequenceName = GetNW2Var( ply, "uTaunt-Name" )
                if sequenceName == nil
                    if label.SequenceName ~= nil
                        label.SequenceName = nil
                        label\SetText( "#unknown_taunts.menu.none" )

                    return

                sequenceID = LookupSequence( ply, sequenceName )
                if sequenceID < 1
                    if label.SequenceName ~= nil
                        label.SequenceName = nil
                        label\SetText( "#unknown_taunts.menu.none" )

                    return

                if label.SequenceName ~= sequenceName
                    label.SequenceName = sequenceName
                    label.SequenceTitle = getPhrase( "unknown_taunts." .. sequenceName )

                duration = SequenceDuration( ply, sequenceID )
                timeRemaining = duration * getCycle( ply, sequenceID )
                if timeRemaining > 60
                    timeRemaining = Round( timeRemaining / 60, 1 ) .. "m"
                else
                    timeRemaining = floor( timeRemaining ) .. "s"

                if duration > 60
                    duration = Round( duration / 60, 1 ) .. "m"
                else
                    duration = floor( duration ) .. "s"

                str = label.SequenceTitle .. " ( " .. timeRemaining .. " / " .. duration .. " )"
                if str ~= label\GetText!
                    label\SetText( str )

        Run "UnknownTauntMenuSetup", ply, ( title, sequences ) ->
            if not istable( sequences )
                return

            length = #sequences
            if length == 0
                return

            for index = 1, length
                if Run( "AllowUnknownTaunt", ply, sequences[ index ], title ) == false
                    sequences[ index ] = false

            length = #sequences
            if length == 0
                return

            combo = @[ title ]
            unless combo and combo\IsValid!
                label = scrollPanel\Add( "DLabel" )
                label\SetText( title )
                label\Dock( TOP )

                combo = scrollPanel\Add( "DComboBox" )
                @[ title ] = combo

                combo\SetText( "#unknown_taunts.menu.select" )
                combo\Dock( TOP )

                combo.OnSelect = ( _, __, ___, name ) ->
                    RunConsoleCommand( "utaunt", name )

                    if utaunt_menu_auto_close\GetBool!
                        @Close!
                        return

                    combo\SetText( "#unknown_taunts.menu.select" )

            for index = 1, length
                if sequences[ index ] ~= false
                    combo\AddChoice( getPhrase( "unknown_taunts." .. sequences[ index ] ), sequences[ index ] )

    PANEL.PerformLayout = ( width, height ) =>
        scrollPanel = @ScrollPanel
        if scrollPanel and scrollPanel\IsValid!
            height = 0
            for pnl in *scrollPanel\GetCanvas!\GetChildren!
                height += pnl\GetTall!

            if height == 0
                @Remove!
                return

            @SetTall( math.min( height + 48, ScrH! * 0.5 ) )

        DFrame.PerformLayout( @, width, height )

    PANEL.Paint = ( width, height ) =>
        SetDrawColor( 50, 50, 50, 220 )
        DrawRect( 0, 0, width, height )

    vgui.Register( "uTaunt::Menu", PANEL, "DFrame" )

do

    HSVToColor = HSVToColor
    :Round = math
    MsgC = MsgC

    concommand.Add "utaunt_list", ( ply, _, args ) ->
        modelSequences = GetSequenceList( ply )
        allowAll = args[ 1 ] == "1"
        sequences, count = {}, 0

        for index = 1, #modelSequences
            sequenceName = modelSequences[ index ]
            if not allowAll and Run( "AllowUnknownTaunt", ply, sequenceName, "Sequences" ) == false
                continue

            placeholder = "unknown_taunts." .. sequenceName
            fulltext = GetPhrase( placeholder )
            if not allowAll and fulltext == placeholder
                continue

            count += 1

            duration = SequenceDuration( ply, index )
            if duration > 60
                sequences[ count ] = sequenceName .. " (" .. Round( duration / 60, 1 ) .. " minutes) - " .. fulltext
                continue

            sequences[ count ] = sequenceName .. " (" .. Round( duration, 2 ) .. " seconds) - " .. fulltext

        if count == 0
            MsgC( "No sequences found.\n" )
            return

        MsgC( "Sequences:\n" )
        for index = 1, count
            MsgC( index .. ". ", HSVToColor( ( 180 + index ) % 360, 1, 1 ), sequences[ index ], "\n" )

list.Set "DesktopWindows", "utaunt-menu", {
    title: "uTaunt"
    icon: "icon16/color_swatch.png"
    init: ( icon, window ) ->
        if window and window\IsValid!
            window\Remove!

        icon.DoClick = ->
            RunConsoleCommand( "utaunts" )

        RunConsoleCommand( "utaunts" )
}
