_G = _G

import string, tonumber, istable, isnumber, isvector, isangle, FindMetaTable, CreateConVar, CurTime, CLIENT, SERVER from _G
import sub, lower, find, match, Trim from string

PLAYER, ENTITY = FindMetaTable( "Player" ), FindMetaTable( "Entity" )
import LookupBone, GetBonePosition, GetCollisionGroup from ENTITY
import Exists from file
import bor from bit

-- ULib support ( I really don't like this )
if Exists( "ulib/shared/hook.lua", "LUA" )
    include( "ulib/shared/hook.lua" )

PRE_HOOK = _G.PRE_HOOK or _G.HOOK_MONITOR_HIGH

addonName = "Unknown Taunts"

lib = _G.uTaunt
unless istable( lib )
    lib = { Name: addonName }
    global uTaunt = lib

webSounds = list.GetForEdit( "uTaunt - WebSounds", false )
coopDances = list.GetForEdit( "uTaunt - Coop", false )

timer.Simple 0.5, ->
    for sequenceName, value in pairs( coopDances )
        if not isnumber( value ) or value < 1
            continue

        name, danceID = match( sequenceName, "^([%a_]+_?)(%d+)$" )
        if name == nil or danceID == nil
            continue

        danceID = tonumber( danceID )
        if danceID == nil
            continue

        for index = 1, value
            coopDances[ name .. ( danceID + index ) ] = 0

import IsValid, GetNW2Var, SetNW2Var, LookupSequence, SequenceDuration, GetSequenceList, IsDormant from ENTITY
import ACT_GMOD_TAUNT_DANCE, GESTURE_SLOT_CUSTOM from _G
import Alive, Crouching from PLAYER
import Add, Run from hook

isPlayingCTaunt = PLAYER.IsPlayingCTaunt
unless isPlayingCTaunt
    isPlayingCTaunt = PLAYER.IsPlayingTaunt
    PLAYER.IsPlayingCTaunt = isPlayingCTaunt

lib.GetSequenceName = ( ply ) ->
    return GetNW2Var( ply, "uTaunt-Name", "" )

local getRenderAngles
do

    import EyeAngles from ENTITY

    getRenderAngles = lib.GetRenderAngles = ( ply ) ->
        angles = EyeAngles( ply )
        angles[ 1 ], angles[ 3 ] = 0, 0
        return GetNW2Var( ply, "uTaunt-Angles", angles )

isPlayingTaunt = lib.IsPlayingTaunt = ( ply ) ->
    return GetNW2Var( ply, "uTaunt-Name" ) ~= nil

getStartTime = lib.GetStartTime = ( ply ) ->
    return GetNW2Var( ply, "uTaunt-Start" ) or CurTime!

lib.GetWebSound = ( sequenceName ) ->
    return webSounds[ sequenceName ]

lib.HasWebSound = ( sequenceName ) ->
    return webSounds[ sequenceName ] ~= nil

local findSound
do

    import GetTable from sound

    sounds = list.GetForEdit( "uTaunt - Sounds", false )
    supportedExtensions = { "mp3", "wav", "ogg" }

    soundExists = lib.SoundExists = ( sequenceName ) ->
        if Exists( "sound/unknown-taunts/" .. sequenceName, "GAME" )
            return true

        return false

    findSound = lib.FindSound = ( sequenceName ) ->
        if sounds[ sequenceName ]
            return sounds[ sequenceName ]

        for extension in *supportedExtensions
            if soundExists( sequenceName .. "." .. extension )
                return "unknown-taunts/" .. sequenceName .. "." .. extension

        sequenceName = "uTaunt." .. sequenceName
        for soundName in *GetTable!
            if soundName == sequenceName
                return soundName

PLAYER.IsPlayingTaunt = lib.IsPlayingAnyTaunt = ( ply ) ->
    return ply.m_bIsPlayingTaunt

local getCycle
do

    import Clamp from math

    getCycle = lib.GetCycle = ( ply, sequenceID, startTime ) ->
        return Clamp( ( CurTime! - ( startTime or getStartTime( ply ) ) ) / SequenceDuration( ply, sequenceID ), 0, 1 )

do

    length, id, duration = 0, 0, 0

    lib.FindSequences = ( entity, pattern ) ->
        sequences, length = {}, 0

        for name in *GetSequenceList( entity )
            if find( name, pattern, 1, false ) == nil
                continue

            id = LookupSequence( entity, name )
            if id < 1
                continue

            duration = SequenceDuration( entity, id )
            if duration <= 0
                continue

            length += 1
            sequences[ length ] = { :id, :name, :duration }

        return sequences, length

isValidTauntingPlayer = lib.IsValidTauntingPlayer = ( ply ) ->
    return ply and IsValid( ply ) and Alive( ply ) and isPlayingTaunt( ply )

import GetInt, GetFloat, GetBool from FindMetaTable( "ConVar" )

local sv_utaunt_allow_weapons, sv_utaunt_allow_movement, sv_utaunt_allow_attack, sv_utaunt_audio_volume, sv_utaunt_camera_distance_min, sv_utaunt_camera_distance_max
do

    flags = bor( FCVAR_REPLICATED, FCVAR_ARCHIVE, FCVAR_NOTIFY )

    sv_utaunt_allow_weapons = CreateConVar( "sv_utaunt_allow_weapons", "0", flags, "Allow players to hold weapons in their hands while taunting.", 0, 1 )
    sv_utaunt_allow_movement = CreateConVar( "sv_utaunt_allow_movement", "0", flags, "Allow players to move while taunting.", 0, 1 )
    sv_utaunt_allow_attack = CreateConVar( "sv_utaunt_allow_attack", "0", flags, "Allow players to attack while taunting.", 0, 1 )
    sv_utaunt_audio_volume = CreateConVar( "sv_utaunt_audio_volume", "1", flags, "Volume of taunts audio.", 0, 10 )

    sv_utaunt_camera_distance_min = CreateConVar( "sv_utaunt_camera_distance_min", "16", flags, "Minimum distance of taunt camera.", 0, 2 ^ 12 )
    sv_utaunt_camera_distance_max = CreateConVar( "sv_utaunt_camera_distance_max", "1024", flags, "Maximum distance of taunt camera.", 0, 2 ^ 12 )

    sv_utaunt_audio_override = CreateConVar( "sv_utaunt_audio_override", "", flags, "Overrides the audio of all taunts to the specified one. Leave it blank so it won't be used." )

    Add "UnknownTauntSound", addonName .. "::SoundOverride", ->
        value = sv_utaunt_audio_override\GetString!
        if #value == 0
            return

        if value == "0"
            return false

        return value

if SERVER

    resource.AddWorkshop( "3161527342" )
    :GetInfo = PLAYER

    lib.SetSequenceName = ( ply, sequenceName ) ->
        SetNW2Var( ply, "uTaunt-Name", sequenceName )

    lib.SetRenderAngles = ( ply, angles ) ->
        SetNW2Var( ply, "uTaunt-Angles", angles )

    lib.SetCycle = ( ply, cycle, sequenceID ) ->
        unless isnumber( cycle )
            cycle = 0

        unless isnumber( sequenceID )
            sequenceName = GetNW2Var( ply, "uTaunt-Name" )
            if sequenceName == nil
                return false

            sequenceID = LookupSequence( ply, sequenceName )

        if sequenceID < 1
            return false

        SetNW2Var( ply, "uTaunt-Start", CurTime! - ( cycle * SequenceDuration( ply, sequenceID ) ) )
        return true

    lib.IsAudioEnabled = ( ply ) ->
        return GetInfo( ply, "cl_utaunt_audio" ) == "1"

    lib.IsCoopEnabled = ( ply ) ->
        return GetInfo( ply, "cl_utaunt_coop" ) == "1"

    lib.IsLoopingEnabled = ( ply ) ->
        return GetInfo( ply, "cl_utaunt_loop" ) == "1"

    sv_utaunt_menu_key, sv_utaunt_real_origin, sv_utaunt_coop_distance, sv_utaunt_collisions = nil, nil, nil, nil
    do

        flags = bor( FCVAR_ARCHIVE, FCVAR_NOTIFY )
        sv_utaunt_menu_key = CreateConVar( "sv_utaunt_menu_key", KEY_I, flags, "Default key to open menu of unknown taunts, uses keys from https://wiki.facepunch.com/gmod/Enums/KEY", 0, 512 )
        sv_utaunt_real_origin = CreateConVar( "sv_utaunt_real_origin", "0", flags, "Uses the player's real position instead of initial position at the end of taunt.", 0, 1 )
        sv_utaunt_coop_distance = CreateConVar( "sv_utaunt_coop_distance", "512", flags, "Minimum required distance to join in a co-op taunt.", 0, 16384 )
        sv_utaunt_collisions = CreateConVar( "sv_utaunt_collisions", "0", flags, "Allow players to collide with each other while taunting.", 0, 1 )

    :GetModel, :SetCollisionGroup = ENTITY

    Add( "PlayerInitialSpawn", addonName .. "::CoopData", ( ply ) ->
        ply.m_tUnknownTauntPlayers = {}

    PRE_HOOK )

    do

        sequenceName, sequenceID, curTime, finishTime, timeRemaining = "", 0, 0, 0, 0
        isbool = isbool

        lib.Finish = ( ply, force ) ->
            sequenceName = GetNW2Var( ply, "uTaunt-Name" )
            if sequenceName == nil
                return false

            curTime, timeRemaining = CurTime!, 0
            finishTime = curTime

            sequenceID = LookupSequence( ply, sequenceName )
            if sequenceID > 0
                finishTime = getStartTime( ply ) + SequenceDuration( ply, sequenceID )

                timeRemaining = finishTime - curTime
                if timeRemaining < 0
                    timeRemaining = 0

            if not force and Run( "PlayerShouldFinishTaunt", ply, sequenceName, finishTime < curTime, timeRemaining, sequenceID, finishTime ) == false
                return false

            -- Origin
            origin = ply.m_vUnknownTauntOrigin
            if GetBool( sv_utaunt_real_origin )
                leftFoot, rightFoot = LookupBone( ply, "ValveBiped.Bip01_L_Foot" ), LookupBone( ply, "ValveBiped.Bip01_R_Foot" )
                if leftFoot > 0 and rightFoot > 0
                    origin = ( GetBonePosition( ply, leftFoot ) + GetBonePosition( ply, rightFoot ) ) / 2
                else
                    origin = GetBonePosition( ply, 0 )

            if isvector( origin )
                ply\SetPos( origin )

            ply.m_vUnknownTauntOrigin = nil

            ply\AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
            SetNW2Var( ply, "uTaunt-Name", nil )
            ply\CrosshairEnable!

            -- Angles
            angles = GetNW2Var( ply, "uTaunt-Angles" )
            if isangle( angles )
                angles[ 1 ], angles[ 3 ] = 0, 0
                ply\SetEyeAngles( angles )

            SetNW2Var( ply, "uTaunt-Angles", nil )

            -- Coop players
            players = ply.m_tUnknownTauntPlayers
            for index = 1, #players
                otherPlayer = players[ index ]
                players[ index ] = nil

                if isValidTauntingPlayer( otherPlayer )
                    lib.Finish( otherPlayer, force )

            -- Collision group
            collisionGroup = ply.m_iUnknownTauntCollisionGroup
            if isnumber( collisionGroup )
                SetCollisionGroup( ply, collisionGroup )

            ply.m_iUnknownTauntCollisionGroup = nil

            -- Player pushing
            avoidPlayers = ply.m_bUnknownTauntAvoidPlayers
            if isbool( avoidPlayers )
                ply\SetAvoidPlayers( avoidPlayers )

            ply.m_bUnknownTauntAvoidPlayers = nil

            -- Weapon
            className = ply.m_sUnknownTauntWeapon
            if isstring( className )
                ply\SelectWeapon( className )

            ply.m_sUnknownTauntWeapon = nil

            -- Sound/Music
            cSound = ply.m_csUnknownTauntSound
            if cSound and cSound\IsPlaying!
                cSound\Stop!

            ply.m_csUnknownTauntSound = nil

            Run( "PlayerFinishedTaunt", ply, sequenceName, finishTime < curTime, timeRemaining, sequenceID, finishTime )
            return true

    forcedFinish = ( ply ) ->
        lib.Finish( ply, true )
        return

    Add "PlayerDisconnected", addonName .. "::Finish", forcedFinish, PRE_HOOK
    Add "PostPlayerDeath", addonName .. "::Finish", forcedFinish, PRE_HOOK
    Add "PlayerSpawn", addonName .. "::Finish", forcedFinish, PRE_HOOK

    Add "PlayerShouldTaunt", addonName .. "::DefaultTauntBlocking", ( ply, _, isUTaunt ) ->
        if not isUTaunt and isPlayingTaunt( ply )
            return false

    :DistToSqr = FindMetaTable( "Vector" )
    import Iterator from player

    maxDistance = GetInt( sv_utaunt_coop_distance ) ^ 2
    cvars.AddChangeCallback( sv_utaunt_coop_distance\GetName!, ( _, __, value ) ->
        maxDistance = ( tonumber( value ) or 0 ) ^ 2
    addonName )

    lib.Start = ( ply, sequenceName, force, cycle, noSound, startOrigin, startAngles ) ->
        if isPlayingCTaunt( ply )
            if isPlayingTaunt( ply )
                forcedFinish( ply )

            return false

        sequenceID = LookupSequence( ply, sequenceName )
        if sequenceID < 1
            return false

        unless force
            if Run( "PlayerShouldUnknownTaunt", ply, sequenceID ) ~= true or Run( "PlayerShouldTaunt", ply, ACT_GMOD_TAUNT_DANCE, true ) == false
                return false

            if GetInfo( ply, "cl_utaunt_coop" ) == "1" and maxDistance > 0
                origin = GetBonePosition( ply, 0 )

                for _, otherPlayer in Iterator!
                    if not ( Alive( otherPlayer ) and otherPlayer.m_bIsPlayingTaunt ) or otherPlayer == ply
                        continue

                    if GetNW2Var( otherPlayer, "uTaunt-Name" ) ~= sequenceName
                        continue

                    if DistToSqr( origin, GetBonePosition( otherPlayer, 0 ), nil ) > maxDistance
                        continue

                    unless otherPlayer\IsBot! or GetInfo( otherPlayer, "cl_utaunt_coop" ) == "1"
                        continue

                    if Run( "PlayerShouldCoopTaunt", ply, otherPlayer, sequenceName ) == false
                        continue

                    if lib.Join( ply, otherPlayer )
                        return true

        duration = SequenceDuration( ply, sequenceID )
        if duration < 0.25
            return false

        if isPlayingTaunt( ply )
            forcedFinish( ply )

        ply.m_sUnknownTauntModel = GetModel( ply )

        if isvector( startOrigin )
            ply.m_vUnknownTauntOrigin = ply\GetPos!
            ply\SetPos( startOrigin )

        unless isangle( startAngles )
            startAngles = getRenderAngles( ply )

        SetNW2Var( ply, "uTaunt-Angles", startAngles )

        unless GetBool( sv_utaunt_collisions )
            ply.m_iUnknownTauntCollisionGroup = GetCollisionGroup( ply )
            ply.m_bUnknownTauntAvoidPlayers = ply\GetAvoidPlayers!
            ply\SetAvoidPlayers( false )

        unless GetBool( sv_utaunt_allow_weapons )
            weapon = ply\GetActiveWeapon!
            if weapon and IsValid( weapon )
                ply.m_sUnknownTauntWeapon = weapon\GetClass!
                ply\SetActiveWeapon!

        unless cycle
            cycle = 0

        SetNW2Var( ply, "uTaunt-Start", CurTime! - ( cycle * duration ) )
        SetNW2Var( ply, "uTaunt-Name", sequenceName )

        ply\AddVCDSequenceToGestureSlot( GESTURE_SLOT_CUSTOM, sequenceID, 0, true )
        ply\CrosshairDisable!

        if noSound or not ( GetInfo( ply, "cl_utaunt_audio" ) == "1" or ply\IsBot! )
            SetNW2Var( ply, "uTaunt-WebAudio", false )

        elseif webSounds[ sequenceName ] ~= nil
            SetNW2Var( ply, "uTaunt-WebAudio", true )

        else

            soundPath = Run( "UnknownTauntSound", ply, sequenceName, cycle, duration, sequenceID )
            if soundPath == false
                SetNW2Var( ply, "uTaunt-WebAudio", false )

            else

                if soundPath == nil or soundPath == true
                    soundPath = findSound( sequenceName )

                if soundPath and find( soundPath, "^https?://.+$" ) == nil and not Exists( soundPath, "GAME" )
                    SetNW2Var( ply, "uTaunt-WebAudio", false )
                    cSound = CreateSound( ply, soundPath )
                    ply.m_csUnknownTauntSound = cSound
                    cSound\ChangeVolume( 0, 0 )
                    cSound\SetDSP( 1 )
                    cSound\Play!

                    cSound\ChangeVolume( 1, 1 )

                else

                    SetNW2Var( ply, "uTaunt-WebAudio", true )

        Run( "PlayerStartTaunt", ply, ACT_GMOD_TAUNT_DANCE, duration )
        Run( "PlayerStartedUnknownTaunt", ply, sequenceName, duration )
        return true

    lib.Join = ( ply, otherPlayer ) ->
        sequenceName = GetNW2Var( otherPlayer, "uTaunt-Name" )
        if sequenceName == nil
            return false

        sequenceID = LookupSequence( ply, sequenceName )
        if sequenceID < 1
            return false

        players = otherPlayer.m_tUnknownTauntPlayers
        if not isnumber( coopDances[ sequenceName ] ) or coopDances[ sequenceName ] < 1
            players[] = ply
            return lib.Start( ply, sequenceName, true, getCycle( otherPlayer, sequenceID ), true )

        danceName, danceID = match( sequenceName, "^([%a_]+_?)(%d+)$" )
        if danceName == nil or danceID == nil
            return false

        danceID = tonumber( danceID )
        if danceID == nil
            return false

        for index = 1, coopDances[ sequenceName ]
            if not isValidTauntingPlayer( players[ index ] ) or players[ index ] == ply
                players[ index ] = ply
                return lib.Start( ply, danceName .. ( danceID + index ), true, getCycle( otherPlayer, sequenceID ), true, otherPlayer\GetPos!, getRenderAngles( otherPlayer ) )

        return false

    do

        import GetVolume from FindMetaTable( "CSoundPatch" )
        import COLLISION_GROUP_PASSABLE_DOOR from _G

        sequenceID, cycle, volume = 0, 0, 0

        Add( "PlayerTauntThink", addonName .. "::Thinking", ( ply, isUTaunt ) ->
            unless isUTaunt
                return

            if not Alive( ply ) or Crouching( ply )
                forcedFinish( ply )
                return

            sequenceName = GetNW2Var( ply, "uTaunt-Name" )
            if sequenceName == nil
                return

            sequenceID = LookupSequence( ply, sequenceName )
            if sequenceID < 1
                forcedFinish( ply )
                return

            if GetModel( ply ) ~= ply.m_sUnknownTauntModel
                forcedFinish( ply )
                return

            cycle = getCycle( ply, sequenceID )
            if Run( "UnknownTauntThink", ply, sequenceName, cycle, sequenceID ) == false or cycle == 1
                lib.Finish( ply, false )
                return

            cSound = ply.m_csUnknownTauntSound
            if cSound
                volume = GetFloat( sv_utaunt_audio_volume )
                if volume > 1
                    volume = 1

                if GetVolume( cSound ) ~= volume
                    cSound\ChangeVolume( volume, 0 )

            if GetBool( sv_utaunt_collisions )
                return

            if GetCollisionGroup( ply ) == COLLISION_GROUP_PASSABLE_DOOR
                return

            SetCollisionGroup( ply, COLLISION_GROUP_PASSABLE_DOOR )
            return

        PRE_HOOK )

    concommand.Add "utaunt", ( ply, _, args ) ->
        if not ( ply and IsValid( ply ) and Alive( ply ) ) or isPlayingCTaunt( ply )
            return

        if isstring( args[ 1 ] )
            lib.Start( ply, args[ 1 ], false )
            return

    concommand.Add "utaunt_stop", ( ply ) ->
        if isPlayingTaunt( ply )
            lib.Finish( ply, false )

    do

        sv_utaunt_gamemode_override = CreateConVar( "sv_utaunt_gamemode_override", "0", bor( FCVAR_ARCHIVE, FCVAR_NOTIFY ), "Overrides gamemode taunt functions to allow players use taunts.", 0, 1 )

        changeOverride = ( _, __, value ) ->
            if value == "1"
                GAMEMODE.__PlayerShouldTaunt = GAMEMODE.__PlayerShouldTaunt or GAMEMODE.PlayerShouldTaunt
                GAMEMODE.PlayerShouldTaunt = ( ply, act ) =>
                    if not ( Alive( ply ) and ply\IsOnGround! ) or Crouching( ply ) or ply\InVehicle! or ply\GetMoveType! ~= MOVETYPE_WALK or ply\WaterLevel! > 1
                        return false

                    return true

            else
                GAMEMODE.PlayerShouldTaunt = GAMEMODE.__PlayerShouldTaunt or GAMEMODE.PlayerShouldTaunt

        cvars.AddChangeCallback( sv_utaunt_gamemode_override\GetName!, changeOverride, addonName )

        timer.Simple 0.25, ->
            changeOverride( nil, nil, sv_utaunt_gamemode_override\GetString! )
            return

    do

        import GetSequenceActivity from ENTITY

        acts = {
            [ ACT_GMOD_TAUNT_DANCE ]: true
            [ ACT_GMOD_TAUNT_ROBOT ]: true
            [ ACT_GMOD_TAUNT_CHEER ]: true
            [ ACT_GMOD_TAUNT_LAUGH ]: true
            [ ACT_GMOD_TAUNT_SALUTE ]: true
            [ ACT_GMOD_TAUNT_MUSCLE ]: true
            [ ACT_GMOD_TAUNT_PERSISTENCE ]: true

            [ ACT_GMOD_GESTURE_BOW ]: true
            [ ACT_GMOD_GESTURE_WAVE ]: true
            [ ACT_GMOD_GESTURE_AGREE ]: true
            [ ACT_GMOD_GESTURE_BECON ]: true
            [ ACT_GMOD_GESTURE_DISAGREE ]: true

            [ ACT_GMOD_GESTURE_RANGE_ZOMBIE ]: true
            [ ACT_GMOD_GESTURE_TAUNT_ZOMBIE ]: true
            [ ACT_GMOD_GESTURE_RANGE_ZOMBIE_SPECIAL ]: true

            [ ACT_GMOD_GESTURE_ITEM_GIVE ]: true
            [ ACT_GMOD_GESTURE_ITEM_DROP ]: true
            [ ACT_GMOD_GESTURE_ITEM_PLACE ]: true
            [ ACT_GMOD_GESTURE_ITEM_THROW ]: true

            [ ACT_SIGNAL_FORWARD ]: true
            [ ACT_SIGNAL_GROUP ]: true
            [ ACT_SIGNAL_HALT ]: true
        }

        Add "PlayerShouldUnknownTaunt", addonName .. "::DefaultSequences", ( ply, sequenceID ) ->
            if acts[ GetSequenceActivity( ply, sequenceID ) ]
                return true

    Add( "PlayerFinishedTaunt", addonName .. "::TauntLooping", ( ply, sequenceName, isFinished ) ->
        if isFinished and GetInfo( ply, "cl_utaunt_loop" ) == "1"
            lib.Start( ply, sequenceName, false )

    PRE_HOOK )

    Add( "PlayerButtonDown", addonName .. "::TauntMenu", ( ply, keyCode ) ->
        if keyCode == GetInt( sv_utaunt_menu_key )
            ply\ConCommand( "utaunts " .. keyCode )
            return

    PRE_HOOK )

Add "PlayerSwitchWeapon", addonName .. "::WeaponSwitch", ( ply ) ->
    if ply.m_bIsPlayingTaunt
        if GetBool( sv_utaunt_allow_weapons )
            return

        return true

do

    import Iterator from player

    players = {}

    Add( "EntityRemoved", addonName .. "::PlayerRemoved", ( entity ) ->
        players[ entity ] = nil
    PRE_HOOK )

    curTime = 0

    Add( "Think", addonName .. "::IsPlayingTaunt", ->
        curTime = CurTime!

        for _, ply in Iterator!
            if IsDormant( ply ) or not Alive( ply )
                if ply.m_bIsPlayingTaunt
                    ply.m_bIsPlayingTaunt = false

                continue

            if isPlayingTaunt( ply )
                players[ ply ] = curTime
                Run( "PlayerTauntThink", ply, true )

            elseif isPlayingCTaunt( ply )
                players[ ply ] = curTime
                Run( "PlayerTauntThink", ply, false )

            unless players[ ply ]
                if ply.m_bIsPlayingTaunt == nil
                    ply.m_bIsPlayingTaunt = false

                continue

            if ( curTime - players[ ply ] ) > 0.1
                ply.m_bIsPlayingTaunt = false
                players[ ply ] = false
            else
                ply.m_bIsPlayingTaunt = true

    PRE_HOOK )

do

    import SetRenderAngles from PLAYER

    Add( "UpdateAnimation", addonName .. "::RenderAngles", ( ply ) ->
        if isPlayingTaunt( ply )
            SetRenderAngles( ply, getRenderAngles( ply ) )
            return
    PRE_HOOK )

do

    import ClearMovement, SetButtons, SetImpulse, KeyDown, RemoveKey from FindMetaTable( "CUserCmd" )
    import IN_ATTACK, IN_ATTACK2, IN_DUCK, IN_JUMP from _G
    import band from bit

    buttons = 0

    Add( "StartCommand", addonName .. "::Movement", ( ply, cmd ) ->
        unless ply.m_bIsPlayingTaunt
            return

        buttons = Run( "TauntStartCommand", ply, cmd, GetNW2Var( ply, "uTaunt-Name", "" ) )
        unless buttons and isnumber( buttons )
            buttons = 0

        if KeyDown( cmd, IN_JUMP )
            RemoveKey( cmd, IN_JUMP )

            if isPlayingTaunt( ply ) and CLIENT and ply.m_bIsLocalPlayer
                RunConsoleCommand( "utaunt_stop" )

        if KeyDown( cmd, IN_DUCK )
            RemoveKey( cmd, IN_DUCK )

        unless GetBool( sv_utaunt_allow_movement )
            ClearMovement( cmd )

        if GetBool( sv_utaunt_allow_attack )
            if KeyDown( cmd, IN_ATTACK ) and band( buttons, IN_ATTACK ) == 0
                buttons = bor( buttons, IN_ATTACK )

            if KeyDown( cmd, IN_ATTACK2 ) and band( buttons, IN_ATTACK2 ) == 0
                buttons = bor( buttons, IN_ATTACK2 )

        SetButtons( cmd, buttons )
        SetImpulse( cmd, 0 )
        return
    PRE_HOOK )

unless CLIENT
    return

import CreateClientConVar from _G

cl_utaunt_loop = CreateClientConVar( "cl_utaunt_loop", "0", true, true, "Enables looping for all taunts.", 0, 1 )
cl_utaunt_audio = CreateClientConVar( "cl_utaunt_audio", "1", true, true, "Enables audio playback for taunts that support this feature.", 0, 1 )
cl_utaunt_coop = CreateClientConVar( "cl_utaunt_coop", "1", true, true, "If enabled player will automatically join/synchronize with dance of another player nearby.", 0, 1 )
cl_utaunt_camera_mode = CreateClientConVar( "cl_utaunt_camera_mode", "1", true, false, "0 = Simple third person, 1 = Third person attached to head, 2 = Eyes", 0, 2 )

lib.IsAudioEnabled = ->
    return GetBool( cl_utaunt_audio )

lib.IsCoopEnabled = ->
    return GetBool( cl_utaunt_coop )

lib.IsLoopingEnabled = ->
    return GetBool( cl_utaunt_loop )

lib.GetCameraMode = ->
    return GetInt( cl_utaunt_camera_mode )

import GetPhrase from language

getPhrase = lib.GetPhrase = ( placeholder ) ->
    fulltext = GetPhrase( placeholder )
    if fulltext == placeholder and sub( placeholder, 1, 15 ) == "unknown_taunts."
        return GetPhrase( sub( placeholder, 16 ) )

    return fulltext

localPlayer = LocalPlayer!

local isInTaunt
if _G.IsInTaunt
    isInTaunt = _G.IsInTaunt!
else
    isInTaunt = false

global IsInTaunt = ->
    return isInTaunt

Add( "InitPostEntity", addonName .. "::Initialization", ->
    localPlayer = LocalPlayer!
    localPlayer.m_bIsLocalPlayer = true
    localPlayer.m_bIsPlayingTaunt = false
    lib.Player = localPlayer
PRE_HOOK )

Add( "Think", addonName .. "::IsInTaunt", ->
    if localPlayer and IsValid( localPlayer )
        isInTaunt = localPlayer.m_bIsPlayingTaunt
PRE_HOOK )

Add "HUDShouldDraw", addonName .. "::WeaponSelector", ( name ) ->
    if isInTaunt and name == "CHudWeaponSelection" and not GetBool( sv_utaunt_allow_weapons )
        return false

import Forward from FindMetaTable( "Angle" )
boneID = 0

do

    import GetVolume, SetPos from FindMetaTable( "IGModAudioChannel" )
    import Remove from hook

    mins, maxs = Vector( -512, -512, 0 ), Vector( 512, 512, 512 )

    stopAudio = ( ply ) ->
        channel = ply.m_bcUnknownTauntAudio
        if channel and channel\IsValid!
            channel\Stop!

        ply.m_bcUnknownTauntAudio = nil

    playStates = {
        [ GMOD_CHANNEL_PLAYING ]: true
        [ GMOD_CHANNEL_STALLED ]: true
    }

    Add( "UnknownTauntSynced", addonName .. "::Sync", ( ply, sequenceName, cycle, sequenceID, webAudio ) ->
        mins[ 3 ] = ply\GetModelRenderBounds![ 3 ]
        ply\SetRenderBounds( mins, maxs )

        if not webAudio or IsDormant( ply )
            stopAudio( ply )
            return

        filePath = Run( "UnknownTauntSound", ply, sequenceName, cycle, SequenceDuration( ply, sequenceID ) or 0, sequenceID ) or webSounds[ sequenceName ]

        channel = ply.m_bcUnknownTauntAudio
        if channel and channel\IsValid!
            unless filePath
                ply.m_sUnknownTauntAudioFilePath = nil
                ply.m_bcUnknownTauntAudio = nil
                channel\Stop!
                return

            if filePath == ply.m_sUnknownTauntAudioFilePath
                length = channel\GetLength!
                if length > 0
                    channel\SetTime( length * cycle )

                unless playStates[ channel\GetState! ]
                    channel\Play!

                return

            ply.m_sUnknownTauntAudioFilePath = nil
            ply.m_bcUnknownTauntAudio = nil
            channel\Stop!

        unless filePath
            return

        isURL = find( filePath, "^https?://.+$" ) ~= nil
        unless isURL or Exists( filePath, "GAME" )
            return

        sound[ isURL and "PlayURL" or "PlayFile" ] filePath, "3d noplay noblock", ( newChannel ) ->
            unless newChannel and newChannel\IsValid! and isValidTauntingPlayer( ply ) and not IsDormant( ply )
                return

            ply.m_sUnknownTauntAudioFilePath = filePath
            ply.m_bcUnknownTauntAudio = newChannel

            length = newChannel\GetLength!
            if length > 0
                newChannel\SetTime( length * cycle )

            newChannel\Play!

            Add "Think", newChannel, ->
                if not isValidTauntingPlayer( ply ) or IsDormant( ply )
                    Remove( "Think", newChannel )

                    if IsValid( ply )
                        ply.m_sUnknownTauntAudioFilePath = nil
                        ply.m_bcUnknownTauntAudio = nil

                    newChannel\Stop!
                    return

                if GetVolume( newChannel ) ~= GetFloat( sv_utaunt_audio_volume )
                    newChannel\SetVolume( GetFloat( sv_utaunt_audio_volume ) )

                boneID = LookupBone( ply, "ValveBiped.Bip01_Head1" )
                if boneID and boneID >= 0
                    SetPos( newChannel, GetBonePosition( ply, boneID ), Forward( getRenderAngles( ply ) ) )
                    return

                SetPos( newChannel, ply\WorldSpaceCenter!, Forward( getRenderAngles( ply ) ) )
                return

            return

        return
    PRE_HOOK )

    Add( "PlayerFinishedTaunt", addonName .. "::Cleanup", ( ply ) ->
        ply\SetRenderBounds( ply\GetModelRenderBounds! )
        stopAudio( ply )
        return

    PRE_HOOK )

do

    cycle = 0

    Add( "EntityNetworkedVarChanged", addonName .. "::Networking", ( ply, key, oldValue, value ) ->
        unless IsValid( ply ) and ply\IsPlayer! and Alive( ply )
            return

        if key == "uTaunt-Name"
            if value == nil
                if ply.m_bUsingUnknownTaunt
                    ply.m_bUsingUnknownTaunt = false
                    ply\AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
                    Run( "PlayerFinishedTaunt", ply, oldValue )

                return

            sequenceID = LookupSequence( ply, value )
            if sequenceID < 1
                return

            ply.m_bUsingUnknownTaunt = true

            cycle = getCycle( ply, sequenceID )
            ply\AddVCDSequenceToGestureSlot( GESTURE_SLOT_CUSTOM, sequenceID, cycle, true )
            Run( "UnknownTauntSynced", ply, value, cycle, sequenceID, GetNW2Var( ply, "uTaunt-WebAudio", false ) )
            return

        if key == "uTaunt-Start"
            sequenceName = GetNW2Var( ply, "uTaunt-Name" )
            if sequenceName == nil
                if ply.m_bUsingUnknownTaunt
                    ply.m_bUsingUnknownTaunt = false
                    ply\AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
                    Run( "PlayerFinishedTaunt", ply, sequenceName )

                return

            sequenceID = LookupSequence( ply, sequenceName )
            if sequenceID < 1
                return

            ply.m_bUsingUnknownTaunt = true

            cycle = getCycle( ply, sequenceID, value )
            ply\AddVCDSequenceToGestureSlot( GESTURE_SLOT_CUSTOM, sequenceID, cycle, true )
            Run( "UnknownTauntSynced", ply, sequenceName, cycle, sequenceID, GetNW2Var( ply, "uTaunt-WebAudio", false ) )
            return

        if key == "uTaunt-WebAudio"
            sequenceName = GetNW2Var( ply, "uTaunt-Name" )
            if sequenceName == nil
                if ply.m_bUsingUnknownTaunt
                    ply.m_bUsingUnknownTaunt = false
                    ply\AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
                    Run( "PlayerFinishedTaunt", ply, sequenceName )

                return

            sequenceID = LookupSequence( ply, sequenceName )
            if sequenceID < 1
                return

            ply.m_bUsingUnknownTaunt = true

            cycle = getCycle( ply, sequenceID )
            ply\AddVCDSequenceToGestureSlot( GESTURE_SLOT_CUSTOM, sequenceID, cycle, true )
            Run( "UnknownTauntSynced", ply, sequenceName, cycle, sequenceID, value == true )
            return

    PRE_HOOK )

    Add( "NotifyShouldTransmit", addonName .. "::PVS", ( ply, shouldtransmit ) ->
        unless shouldtransmit and IsValid( ply ) and ply\IsPlayer! and Alive( ply )
            if ply.m_bUsingUnknownTaunt
                ply.m_bUsingUnknownTaunt = false
                ply\AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
                Run( "PlayerFinishedTaunt", ply, oldValue )

            return

        sequenceName = GetNW2Var( ply, "uTaunt-Name" )
        if sequenceName == nil
            if ply.m_bUsingUnknownTaunt
                ply.m_bUsingUnknownTaunt = false
                ply\AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
                Run( "PlayerFinishedTaunt", ply, oldValue )

            return

        sequenceID = LookupSequence( ply, sequenceName )
        if sequenceID < 1
            return

        ply.m_bUsingUnknownTaunt = true

        cycle = getCycle( ply, sequenceID )
        ply\AddVCDSequenceToGestureSlot( GESTURE_SLOT_CUSTOM, sequenceID, cycle, true )
        Run( "UnknownTauntSynced", ply, sequenceName, cycle, sequenceID )
        return

    PRE_HOOK )

toggleMenu = lib.ToggleMenu = ( ply, keyCode ) ->
    if isPlayingCTaunt( ply )
        return false

    if keyCode ~= nil
        bind = input.LookupKeyBinding( keyCode )
        if bind ~= nil and #bind > 0
            return false

    panel = lib.Panel
    if panel and panel\IsValid!
        panel\Remove!
        return true

    if Run( "AllowTauntMenu", ply ) == false
        return false

    panel = vgui.Create( "uTaunt::Menu" )
    lib.Panel = panel
    panel\Setup( ply )
    return true

concommand.Add "utaunts", ( ply, _, args ) ->
    unless ply\Alive!
        return

    keyCode = args[ 1 ]
    if keyCode ~= nil and #keyCode > 0
        keyCode = tonumber( keyCode )

    toggleMenu( ply, keyCode )
    return

do

    commmands = { "taunt", "dance", "utaunt", "udance" }
    allowedChars = { "/": true, "!": true }

    Add "OnPlayerChat", addonName .. "::ChatCommands", ( ply, text, isTeam, isDead ) ->
        if isDead or isTeam or not ply.m_bIsLocalPlayer
            return

        text = lower( Trim( text ) )

        if allowedChars[ sub( text, 1, 1 ) ] == nil
            return

        text = sub( text, 2 )

        for command in *commmands
            if find( text, command, 1, false ) ~= nil
                toggleMenu( ply )
                return true

-- Default Sequences
do

    import format from string

    taunts = {
        "taunt_cheer"
        "taunt_dance"
        "taunt_laugh"
        "taunt_muscle"
        "taunt_robot"
        "taunt_persistence"
        "taunt_zombie"
    }

    gestures = {
        "gesture_agree"
        "gesture_bow"
        "gesture_becon"
        "gesture_disagree"
        "gesture_salute"
        "gesture_wave"

        "gesture_item_drop"
        "gesture_item_give"
        "gesture_item_place"
        "gesture_item_throw"

        "gesture_signal_forward"
        "gesture_signal_halt"
        "gesture_signal_group"
    }

    zombie = {
        "zombie_attack_01"
        "zombie_attack_02"
        "zombie_attack_03"
        "zombie_attack_04"
        "zombie_attack_05"
        "zombie_attack_06"
        "zombie_attack_07"
        "zombie_attack_special"
    }

    Add "UnknownTauntMenuSetup", addonName .. "::DefaultSequences", ( ply, add ) ->
        sequences, sequencesCount = {}, 0
        for sequenceName in *taunts
            if LookupSequence( ply, sequenceName ) < 0
                continue

            sequencesCount += 1
            sequences[ sequencesCount ] = sequenceName

        if sequencesCount > 0
            add( format( GetPhrase( "unknown_taunts.menu.taunts" ), "Garry's Mod" ), sequences )

            for index = 1, sequencesCount
                sequences[ index ] = nil

            sequencesCount = 0

        for sequenceName in *gestures
            if LookupSequence( ply, sequenceName ) < 0
                continue

            sequencesCount += 1
            sequences[ sequencesCount ] = sequenceName

        if sequencesCount > 0
            add( format( GetPhrase( "unknown_taunts.menu.gestures" ), "Garry's Mod" ), sequences )

            for index = 1, sequencesCount
                sequences[ index ] = nil

            sequencesCount = 0

        for sequenceName in *zombie
            if LookupSequence( ply, sequenceName ) < 0
                continue

            sequencesCount += 1
            sequences[ sequencesCount ] = sequenceName

        if sequencesCount > 0
            add( format( GetPhrase( "unknown_taunts.menu.zombie" ), "Garry's Mod" ), sequences )

        return

do

    import DrawRect, SetDrawColor from surface
    import floor, Round from math

    cl_utaunt_menu_auto_close = CreateClientConVar( "cl_utaunt_menu_auto_close", "0", true, false, "Automatically close the taunt menu when a taunt is selected.", 0, 1 )

    PANEL = {}

    PANEL.Init = =>
        @SetTitle( "#unknown_taunts.menu.title" )
        @SetSize( ScreenScale( 128 ), 24 )
        @SetIcon( "icon16/user.png" )
        @MakePopup!
        @Center!

    PANEL.ClickSound = ->
        surface.PlaySound( "garrysmod/ui_click.wav" )

    PANEL.Setup = ( ply ) =>
        scrollPanel = @Add( "DScrollPanel" )
        @ScrollPanel = scrollPanel
        scrollPanel\Dock( FILL )

        scrollPanel.PerformLayout = ( _, width, height ) ->
            canvas = scrollPanel\GetCanvas!
            if canvas and canvas\IsValid!
                margin = ScreenScale( 2 )
                canvas\DockPadding( margin, 0, margin, margin )

            DScrollPanel.PerformLayout( scrollPanel, width, height )

        actions = scrollPanel\Add( "EditablePanel" )
        actions.Progress = 0
        actions\Dock( TOP )

        actions.PerformLayout = ->
            actions\SetTall( 32 )

        actions.Think = ->
            sequenceName = GetNW2Var( ply, "uTaunt-Name" )
            if sequenceName == nil
                actions.Progress = 0
                return

            sequenceID = LookupSequence( ply, sequenceName )
            if sequenceID < 1
                actions.Progress = 0
                return

            actions.Progress = getCycle( ply, sequenceID )

        actions.Paint = ( _, width, height ) ->
            SetDrawColor( 150, 255, 50, 220 )
            DrawRect( 0, height - 2, width * actions.Progress, 2 )

        do

            button = actions\Add( "DButton" )
            button\SetText( "" )
            button\SetWide( 32 )
            button\Dock( RIGHT )
            button.Paint = ->

            button.UpdateIcon = ( state ) ->
                button\SetImage( state and "icon16/group.png" or "icon16/user.png" )

            button.UpdateIcon( GetBool( cl_utaunt_coop ) )

            button.DoClick = ->
                if GetBool( cl_utaunt_coop )
                    cl_utaunt_coop\SetBool( false )
                    button.UpdateIcon( false )
                else
                    cl_utaunt_coop\SetBool( true )
                    button.UpdateIcon( true )

                @ClickSound!

        do

            button = actions\Add( "DButton" )
            button\SetText( "" )
            button\SetWide( 32 )
            button\Dock( RIGHT )
            button.Paint = ->

            button.UpdateIcon = ( state ) ->
                icon = "icon16/camera.png"
                if state == 1
                    icon = "icon16/camera_link.png"
                elseif state == 2
                    icon = "icon16/eye.png"

                button\SetImage( icon )

            button.UpdateIcon( GetInt( cl_utaunt_camera_mode ) )

            button.DoClick = ->
                state = GetInt( cl_utaunt_camera_mode ) + 1
                if state > cl_utaunt_camera_mode\GetMax!
                    state = cl_utaunt_camera_mode\GetMin!

                cl_utaunt_camera_mode\SetInt( state )
                button.UpdateIcon( state )
                @ClickSound!

        do

            button = actions\Add( "DButton" )
            button\SetText( "" )
            button\SetWide( 32 )
            button\Dock( RIGHT )
            button.Paint = ->

            button.UpdateIcon = ( state ) ->
                button\SetImage( state and "icon16/sound.png" or "icon16/sound_mute.png" )

            button.UpdateIcon( GetBool( cl_utaunt_audio ) )

            button.DoClick = ->
                if GetBool( cl_utaunt_audio )
                    cl_utaunt_audio\SetBool( false )
                    button.UpdateIcon( false )
                else
                    cl_utaunt_audio\SetBool( true )
                    button.UpdateIcon( true )

                @ClickSound!

        do

            button = actions\Add( "DButton" )
            button\SetText( "" )
            button\SetWide( 32 )
            button\Dock( RIGHT )
            button.Paint = ->

            button.UpdateIcon = ( state ) ->
                button\SetImage( state and "icon16/control_repeat_blue.png" or "icon16/control_repeat.png" )

            button.UpdateIcon( GetBool( cl_utaunt_loop ) )

            button.DoClick = ->
                if GetBool( cl_utaunt_loop )
                    cl_utaunt_loop\SetBool( false )
                    button.UpdateIcon( false )
                else
                    cl_utaunt_loop\SetBool( true )
                    button.UpdateIcon( true )

                @ClickSound!

        do

            button = actions\Add( "DButton" )
            button\SetText( "" )
            button\SetWide( 32 )
            button\Dock( RIGHT )
            button.Paint = ->

            button.Think = ->
                state = isPlayingTaunt( ply )
                if button.State ~= state
                    button.State = state

                    if state
                        button\SetImage( "icon16/control_stop_blue.png" )
                    else
                        button\SetImage( "icon16/control_stop.png" )

            button.DoClick = ->
                if isPlayingTaunt( ply )
                    RunConsoleCommand( "utaunt_stop" )
                    @ClickSound!

        do

            label = actions\Add( "DLabel" )
            label.SequenceName = ""
            label\Dock( FILL )

            label.Think = ->
                unless isPlayingTaunt( ply )
                    if label.SequenceName ~= nil
                        label.SequenceName = nil
                        label\SetText( "#unknown_taunts.menu.none" )

                    return

                sequenceName = GetNW2Var( ply, "uTaunt-Name" )
                if sequenceName == nil
                    if label.SequenceName ~= nil
                        label.SequenceName = nil
                        label\SetText( "#unknown_taunts.menu.none" )

                    return

                sequenceID = LookupSequence( ply, sequenceName )
                if sequenceID < 1
                    if label.SequenceName ~= nil
                        label.SequenceName = nil
                        label\SetText( "#unknown_taunts.menu.none" )

                    return

                if label.SequenceName ~= sequenceName
                    label.SequenceName = sequenceName
                    label.SequenceTitle = getPhrase( "unknown_taunts." .. sequenceName )

                duration = SequenceDuration( ply, sequenceID )
                timeRemaining = duration * getCycle( ply, sequenceID )
                if timeRemaining > 60
                    timeRemaining = Round( timeRemaining / 60, 1 ) .. "m"
                else
                    timeRemaining = floor( timeRemaining ) .. "s"

                if duration > 60
                    duration = Round( duration / 60, 1 ) .. "m"
                else
                    duration = floor( duration ) .. "s"

                str = label.SequenceTitle .. " ( " .. timeRemaining .. " / " .. duration .. " )"
                if str ~= label\GetText!
                    label\SetText( str )

        Run "UnknownTauntMenuSetup", ply, ( title, sequences ) ->
            unless istable( sequences )
                return

            length = #sequences
            if length == 0
                return

            for index = 1, length
                if Run( "AllowUnknownTaunt", ply, sequences[ index ], title ) == false
                    sequences[ index ] = false

            length = #sequences
            if length == 0
                return

            combo = @[ title ]
            unless combo and combo\IsValid!
                label = scrollPanel\Add( "DLabel" )
                label\SetText( title )
                label\Dock( TOP )

                combo = scrollPanel\Add( "DComboBox" )
                @[ title ] = combo

                combo\SetText( "#unknown_taunts.menu.select" )
                combo\Dock( TOP )

                combo.OnSelect = ( _, __, ___, name ) ->
                    RunConsoleCommand( "utaunt", name )

                    if GetBool( cl_utaunt_menu_auto_close )
                        @Close!
                        return

                    combo\SetText( "#unknown_taunts.menu.select" )

            for index = 1, length
                if sequences[ index ] ~= false
                    combo\AddChoice( getPhrase( "unknown_taunts." .. sequences[ index ] ), sequences[ index ] )

    PANEL.PerformLayout = ( width, height ) =>
        scrollPanel = @ScrollPanel
        if scrollPanel and scrollPanel\IsValid!
            height = 0
            for pnl in *scrollPanel\GetCanvas!\GetChildren!
                height += pnl\GetTall!

            if height == 0
                @Remove!
                return

            @SetTall( math.min( height + 48, ScrH! * 0.5 ) )

        DFrame.PerformLayout( @, width, height )

    PANEL.Paint = ( width, height ) =>
        SetDrawColor( 50, 50, 50, 220 )
        DrawRect( 0, 0, width, height )

    vgui.Register( "uTaunt::Menu", PANEL, "DFrame" )

do

    import MsgC, HSVToColor from _G
    import Round from math

    concommand.Add "utaunt_list", ( ply, _, args ) ->
        modelSequences = GetSequenceList( ply )
        allowAll = args[ 1 ] == "1"
        sequences, count = {}, 0

        for index = 1, #modelSequences
            sequenceName = modelSequences[ index ]
            if not allowAll and Run( "AllowUnknownTaunt", ply, sequenceName, "Sequences" ) == false
                continue

            placeholder = "unknown_taunts." .. sequenceName
            fulltext = GetPhrase( placeholder )
            if not allowAll and fulltext == placeholder
                continue

            count += 1

            duration = SequenceDuration( ply, index )
            if duration > 60
                sequences[ count ] = sequenceName .. " (" .. Round( duration / 60, 1 ) .. " minutes) - " .. fulltext
                continue

            sequences[ count ] = sequenceName .. " (" .. Round( duration, 2 ) .. " seconds) - " .. fulltext

        if count == 0
            MsgC( "No sequences found.\n" )
            return

        MsgC( "Sequences:\n" )
        for index = 1, count
            MsgC( index .. ". ", HSVToColor( ( 180 + index ) % 360, 1, 1 ), sequences[ index ], "\n" )

list.Set "DesktopWindows", "utaunt-menu", {
    title: "uTaunt"
    icon: "icon16/color_swatch.png"
    init: ( icon, window ) ->
        if window and window\IsValid!
            window\Remove!

        icon.DoClick = ->
            RunConsoleCommand( "utaunts" )

        RunConsoleCommand( "utaunts" )
}

do

    import FrameTime from _G

    camera_mode = GetInt( cl_utaunt_camera_mode )
    cvars.AddChangeCallback( cl_utaunt_camera_mode\GetName!, ( _, __, value ) ->
        camera_mode = tonumber( value ) or 0
    addonName )

    local viewAngles, eyeAngles, distance

    traceResult = {}
    trace = {
        mins: Vector( -8, -8, -8 )
        maxs: Vector( 8, 8, 8 )
        output: traceResult
        mask: MASK_SHOT
        filter: ( entity ) ->
            return entity.m_bIsPlayingTaunt ~= true
    }

    do

        import vector_origin, LocalToWorld, LerpVector, LerpAngle from _G
        import LookupAttachment, GetAttachment from ENTITY
        import GetViewEntity from PLAYER

        cl_utaunt_camera_distance = CreateClientConVar( "cl_utaunt_camera_distance", "128", true, false, "Distance of the camera from the player." )

        local targetOrigin, targetAngles
        attachmentID, fraction = 0, 0
        view = { drawviewer: true }

        Add "ShouldDrawLocalPlayer", addonName .. "::Compatibility", ->
            if isInTaunt or fraction > 0
                return true

        Add "CalcView", addonName .. "::Compatibility", ( ply, origin, angles ) ->
            unless ( isInTaunt or fraction > 0 ) and Alive( ply ) and GetViewEntity( ply ) == ply
                if eyeAngles
                    eyeAngles = nil

                if viewAngles
                    viewAngles = nil

                if distance
                    distance = nil

                return

            unless eyeAngles
                eyeAngles = Angle( angles )
                eyeAngles[ 1 ], eyeAngles[ 3 ] = 0, 0

            unless viewAngles
                viewAngles = ( camera_mode == 2 ) and Angle! or Angle( eyeAngles )

            if camera_mode == 2
                attachmentID = LookupAttachment( ply, "eyes" )
                if attachmentID and attachmentID > 0
                    data = GetAttachment( ply, attachmentID )
                    targetOrigin, targetAngles = LocalToWorld( vector_origin, viewAngles, data.Pos, data.Ang )
                else
                    boneID = LookupBone( ply, "ValveBiped.Bip01_Head1" )
                    if boneID and boneID > 0
                        targetOrigin, targetAngles = LocalToWorld( vector_origin, viewAngles, GetBonePosition( ply, boneID ) )
                    else
                        targetOrigin, targetAngles = LocalToWorld( vector_origin, viewAngles, GetBonePosition( ply, 0 ) )

            else

                unless distance
                    distance = cl_utaunt_camera_distance\GetInt!

                    if distance < sv_utaunt_camera_distance_min\GetInt!
                        distance = sv_utaunt_camera_distance_min\GetInt!

                    elseif distance > sv_utaunt_camera_distance_max\GetInt!
                        distance = sv_utaunt_camera_distance_max\GetInt!

                if traceResult.HitPos
                    targetOrigin = traceResult.HitPos + traceResult.HitNormal
                else
                    targetOrigin = origin

                targetAngles = viewAngles

            if isInTaunt
                if fraction < 1
                    fraction += FrameTime! * 4

                    if fraction > 1
                        fraction = 1

                    view.origin = LerpVector( fraction, origin, targetOrigin )
                    view.angles = LerpAngle( fraction, eyeAngles, targetAngles )
                    return view

            elseif fraction > 0
                fraction -= FrameTime! * 2

                if fraction < 0
                    fraction = 0

                view.origin = LerpVector( fraction, origin, targetOrigin )
                view.angles = LerpAngle( fraction, eyeAngles, targetAngles )
                return view

            view.origin = targetOrigin
            view.angles = targetAngles
            return view

    do

        import SetViewAngles, GetMouseWheel from FindMetaTable( "CUserCmd" )
        import TraceHull from util
        wheel = 0

        Add( "CreateMove", addonName .. "::Compatibility", ( cmd ) ->
            if eyeAngles
                SetViewAngles( cmd, eyeAngles )

            if camera_mode ~= 2 and viewAngles and distance
                if camera_mode == 1
                    boneID = LookupBone( localPlayer, "ValveBiped.Bip01_Head1" )
                    if boneID and boneID >= 0
                        trace.start = GetBonePosition( localPlayer, boneID )
                    else
                        trace.start = localPlayer\EyePos!
                else
                    trace.start = localPlayer\EyePos!

                trace.endpos = trace.start - Forward( viewAngles ) * distance
                TraceHull( trace )

            return
        PRE_HOOK )

        Add( "InputMouseApply", addonName .. "::Camera", ( cmd, x, y ) ->
            if viewAngles
                if y ~= 0
                    viewAngles[ 1 ] += y * FrameTime!

                    if camera_mode == 2
                        if viewAngles[ 1 ] > 30
                            viewAngles[ 1 ] = 30
                        elseif viewAngles[ 1 ] < -60
                            viewAngles[ 1 ] = -60
                    else
                        if viewAngles[ 1 ] > 90
                            viewAngles[ 1 ] = 90
                        elseif viewAngles[ 1 ] < -90
                            viewAngles[ 1 ] = -90

                if x ~= 0
                    viewAngles[ 2 ] -= x * FrameTime!

                    if camera_mode == 2
                        if viewAngles[ 2 ] > 45
                            viewAngles[ 2 ] = 45
                        elseif viewAngles[ 2 ] < -45
                            viewAngles[ 2 ] = -45
                    else
                        if viewAngles[ 2 ] > 180
                            viewAngles[ 2 ] = -180
                        elseif viewAngles[ 2 ] < -180
                            viewAngles[ 2 ] = 180

            if distance and camera_mode ~= 2
                wheel = GetMouseWheel( cmd )
                if wheel ~= 0
                    distance = distance - wheel * ( distance * 0.1 )

                    if distance < sv_utaunt_camera_distance_min\GetInt!
                        distance = sv_utaunt_camera_distance_min\GetInt!

                    elseif distance > sv_utaunt_camera_distance_max\GetInt!
                        distance = sv_utaunt_camera_distance_max\GetInt!

        PRE_HOOK )
