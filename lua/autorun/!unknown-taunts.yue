PLAYER, ENTITY = FindMetaTable( "Player" ), FindMetaTable( "Entity" )
:sub, :lower, :find, :match, :Trim = string
RunConsoleCommand = RunConsoleCommand
tonumber = tonumber
isnumber = isnumber
isvector = isvector
isangle = isangle
istable = istable
CurTime = CurTime
CLIENT = CLIENT
SERVER = SERVER
:bor = bit

-- ULib support ( I really don't like this )
if file.Exists( "ulib/shared/hook.lua", "LUA" )
    include( "ulib/shared/hook.lua" )

PRE_HOOK = PRE_HOOK or HOOK_MONITOR_HIGH

addonName = "Unknown Taunts"

lib = uTaunt
unless istable( lib )
    lib = { Name: addonName }
    global uTaunt = lib

coopDances = list.GetForEdit( "uTaunt - Coop", false )

timer.Simple 0.5, ->
    for sequenceName, value in pairs( coopDances )
        if not isnumber( value ) or value < 1
            continue

        sequenceName, danceID = match( sequenceName, "^([%a_]+_?)(%d+)$" )
        if sequenceName == nil or danceID == nil
            continue

        danceID = tonumber( danceID )
        if danceID == nil
            continue

        for index = 1, value
            coopDances[ sequenceName .. ( danceID + index ) ] = 0

:IsValid, :GetNW2Var, :SetNW2Var, :LookupSequence, :SequenceDuration, :GetSequenceList = ENTITY
:Add, :Run = hook
:Alive = PLAYER

ACT_GMOD_TAUNT_DANCE = ACT_GMOD_TAUNT_DANCE
GESTURE_SLOT_CUSTOM = GESTURE_SLOT_CUSTOM

isPlayingCTaunt = PLAYER.IsPlayingCTaunt
if isPlayingCTaunt == nil
    isPlayingCTaunt = PLAYER.IsPlayingTaunt
    PLAYER.IsPlayingCTaunt = isPlayingCTaunt

lib.GetSequenceName = ( ply ) ->
    return GetNW2Var( ply, "uTaunt-name", "" )

getRenderAngles = nil
do

    :EyeAngles = ENTITY

    getRenderAngles = ( ply ) ->
        angles = EyeAngles( ply )
        angles[ 1 ], angles[ 3 ] = 0, 0
        return GetNW2Var( ply, "uTaunt-angles", angles )

lib.GetRenderAngles = getRenderAngles

isPlayingTaunt = ( ply ) ->
    return GetNW2Var( ply, "uTaunt-name" ) ~= nil

lib.IsPlayingTaunt = isPlayingTaunt

getStartTime = ( ply ) ->
    return GetNW2Var( ply, "uTaunt-start" ) or CurTime!

lib.GetStartTime = getStartTime

findSound = nil
do

    sounds = list.GetForEdit( "uTaunt - Sounds", false )
    supportedExtensions = { "mp3", "wav", "ogg" }
    :GetTable = sound
    :Exists = file

    soundExists = ( sequenceName ) ->
        if Exists( "sound/unknown-taunts/" .. sequenceName, "GAME" )
            return true

        return false

    lib.SoundExists = soundExists

    findSound = ( sequenceName ) ->
        sequenceName = lower( sequenceName )

        if sounds[ sequenceName ]
            return sounds[ sequenceName ]

        for extension in *supportedExtensions
            extension = sequenceName .. "." .. extension
            if soundExists( extension )
                return "unknown-taunts/" .. extension

        sequenceName = "uTaunt." .. sequenceName
        for soundName in *GetTable!
            if soundName == sequenceName
                return soundName

    lib.FindSound = findSound

isPlayingAnyTaunt = ( ply ) ->
    return ply.m_bIsPlayingTaunt or false

PLAYER.IsPlayingTaunt = isPlayingAnyTaunt
lib.IsPlayingAnyTaunt = isPlayingAnyTaunt

getCycle = nil
do

    :Clamp = math

    getCycle = ( ply, sequenceID, startTime ) ->
        return Clamp( ( CurTime! - ( startTime or getStartTime( ply ) ) ) / SequenceDuration( ply, sequenceID ), 0, 1 )

    lib.GetCycle = getCycle

do

    length, id, duration = 0, 0, 0

    lib.FindSequences = ( entity, pattern ) ->
        sequences, length = {}, 0

        for name in *GetSequenceList( entity )
            if find( name, pattern, 1, false ) == nil
                continue

            id = LookupSequence( entity, name )
            if id < 1
                continue

            duration = SequenceDuration( entity, id )
            if duration <= 0
                continue

            length += 1
            sequences[ length ] = { :id, :name, :duration }

        return sequences, length

isValidTauntingPlayer = ( ply ) ->
    return ply and IsValid( ply ) and Alive( ply ) and isPlayingTaunt( ply )

lib.IsValidTauntingPlayer = isValidTauntingPlayer

utaunt_allow_weapons, utaunt_allow_movement, utaunt_allow_attack = nil, nil, nil
do

    flags = bor( FCVAR_REPLICATED, FCVAR_ARCHIVE, FCVAR_NOTIFY )
    utaunt_allow_weapons = CreateConVar( "utaunt_allow_weapons", "0", flags, "Allow players to hold weapons in their hands while taunting.", 0, 1 )
    utaunt_allow_movement = CreateConVar( "utaunt_allow_movement", "0", flags, "Allow players to move while taunting.", 0, 1 )
    utaunt_allow_attack = CreateConVar( "utaunt_allow_attack", "0", flags, "Allow players to attack while taunting.", 0, 1 )

if SERVER

    resource.AddWorkshop( "3161527342" )
    :GetInfo = PLAYER

    lib.SetSequenceName = ( ply, sequenceName ) ->
        SetNW2Var( ply, "uTaunt-name", sequenceName )

    lib.SetRenderAngles = ( ply, angles ) ->
        SetNW2Var( ply, "uTaunt-angles", angles )

    lib.SetCycle = ( ply, cycle, sequenceID ) ->
        unless isnumber( cycle )
            cycle = 0

        unless isnumber( sequenceID )
            sequenceName = GetNW2Var( ply, "uTaunt-name" )
            if sequenceName == nil
                return false

            sequenceID = LookupSequence( ply, sequenceName )

        if sequenceID < 1
            return false

        SetNW2Var( ply, "uTaunt-start", CurTime! - ( cycle * SequenceDuration( ply, sequenceID ) ) )
        return true

    lib.IsAudioEnabled = ( ply ) ->
        return GetInfo( ply, "utaunt_audio" ) == "1"

    lib.IsCoopEnabled = ( ply ) ->
        return GetInfo( ply, "utaunt_coop" ) == "1"

    utaunt_menu_key, utaunt_real_origin, utaunt_coop_distance, utaunt_collisions = nil, nil, nil, nil
    do

        flags = bor( FCVAR_ARCHIVE, FCVAR_NOTIFY )
        utaunt_menu_key = CreateConVar( "utaunt_menu_key", KEY_I, flags, "Default key to open menu of unknown taunts, uses keys from https://wiki.facepunch.com/gmod/Enums/KEY", 0, 512 )
        utaunt_real_origin = CreateConVar( "utaunt_real_origin", "0", flags, "Uses the player's real position instead of initial position at the end of taunt.", 0, 1 )
        utaunt_coop_distance = CreateConVar( "utaunt_coop_distance", "512", flags, "Minimum required distance to join in a co-op taunt.", 0, 16384 )
        utaunt_collisions = CreateConVar( "utaunt_collisions", "0", flags, "Allow players to collide with each other while taunting.", 0, 1 )

    :GetModel, :SetCollisionGroup = ENTITY

    Add( "PlayerInitialSpawn", addonName, ( ply ) ->
        ply.m_tUnknownTauntPlayers = {}
    PRE_HOOK )

    do

        sequenceName, sequenceID, curTime, finishTime, timeRemaining = "", 0, 0, 0, 0
        isbool = isbool

        lib.Finish = ( ply, force ) ->
            sequenceName = GetNW2Var( ply, "uTaunt-name" )
            if sequenceName == nil
                return false

            curTime, timeRemaining = CurTime!, 0
            finishTime = curTime

            sequenceID = LookupSequence( ply, sequenceName )
            if sequenceID > 0
                finishTime = getStartTime( ply ) + SequenceDuration( ply, sequenceID )

                timeRemaining = finishTime - curTime
                if timeRemaining < 0
                    timeRemaining = 0

            if not force and Run( "PlayerShouldFinishTaunt", ply, sequenceName, finishTime < curTime, timeRemaining, sequenceID, finishTime ) == false
                return false

            -- Origin
            origin = ply.m_vUnknownTauntOrigin
            if utaunt_real_origin\GetBool!
                leftFoot, rightFoot = ply\LookupBone( "ValveBiped.Bip01_L_Foot" ), ply\LookupBone( "ValveBiped.Bip01_R_Foot" )
                if leftFoot > 0 and rightFoot > 0
                    origin = ( ply\GetBonePosition( leftFoot ) + ply\GetBonePosition( rightFoot ) ) / 2
                else
                    origin = ply\GetBonePosition( 0 )

            if isvector( origin )
                ply\SetPos( origin )

            ply.m_vUnknownTauntOrigin = nil

            ply\AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
            SetNW2Var( ply, "uTaunt-name", nil )

            -- Angles
            angles = GetNW2Var( ply, "uTaunt-angles" )
            if isangle( angles )
                angles[ 1 ], angles[ 3 ] = 0, 0
                ply\SetEyeAngles( angles )

            SetNW2Var( ply, "uTaunt-angles", nil )

            -- Coop players
            players = ply.m_tUnknownTauntPlayers
            for index = 1, #players
                otherPlayer = players[ index ]
                players[ index ] = nil

                if isValidTauntingPlayer( otherPlayer )
                    lib.Finish( otherPlayer, force )

            -- Collision group
            collisionGroup = ply.m_iUnknownTauntCollisionGroup
            if isnumber( collisionGroup )
                SetCollisionGroup( ply, collisionGroup )

            ply.m_iUnknownTauntCollisionGroup = nil

            -- Player pushing
            avoidPlayers = ply.m_bUnknownTauntAvoidPlayers
            if isbool( avoidPlayers )
                ply\SetAvoidPlayers( avoidPlayers )

            ply.m_bUnknownTauntAvoidPlayers = nil

            -- Weapon
            className = ply.m_sUnknownTauntWeapon
            if isstring( className )
                ply\SelectWeapon( className )

            ply.m_sUnknownTauntWeapon = nil

            -- Sound/Music
            cSound = ply.m_csUnknownTauntSound
            if cSound and cSound\IsPlaying!
                cSound\Stop!

            ply.m_csUnknownTauntSound = nil

            Run( "PlayerFinishedTaunt", ply, sequenceName, finishTime < curTime, timeRemaining, sequenceID, finishTime )
            return true

    forcedFinish = ( ply ) ->
        lib.Finish( ply, true )
        return

    Add "PlayerDisconnected", addonName, forcedFinish, PRE_HOOK
    Add "PostPlayerDeath", addonName, forcedFinish, PRE_HOOK
    Add "PlayerSpawn", addonName, forcedFinish, PRE_HOOK

    lib.Start = ( ply, sequenceName, force, cycle, noSound, startOrigin, startAngles ) ->
        sequenceID = LookupSequence( ply, sequenceName )
        if sequenceID < 1
            return false

        unless force
            if Run( "PlayerShouldUnknownTaunt", ply, sequenceID ) ~= true or ( not isPlayingTaunt( ply ) and Run( "PlayerShouldTaunt", ply, ACT_GMOD_TAUNT_DANCE ) == false )
                return false

            if GetInfo( ply, "utaunt_coop" ) == "1"
                maxDistance = utaunt_coop_distance\GetInt!
                if maxDistance > 0
                    for otherPlayer in *ents.FindInSphere( ply\GetPos!, maxDistance )
                        unless otherPlayer\IsPlayer! and Alive( otherPlayer )
                            continue

                        if otherPlayer == ply or GetNW2Var( otherPlayer, "uTaunt-name" ) ~= sequenceName or GetInfo( otherPlayer, "utaunt_coop" ) ~= "1"
                            continue

                        if otherPlayer\GetBonePosition( 0 )\Distance( ply\EyePos! ) > maxDistance
                            continue

                        if Run( "PlayerShouldCoopTaunt", ply, otherPlayer, sequenceName ) == false
                            continue

                        if lib.Join( ply, otherPlayer )
                            return true

        duration = SequenceDuration( ply, sequenceID )
        if duration < 0.25
            return false

        if isPlayingTaunt( ply )
            forcedFinish( ply )

        ply.m_sUnknownTauntModel = GetModel( ply )

        if isvector( startOrigin )
            ply.m_vUnknownTauntOrigin = ply\GetPos!
            ply\SetPos( startOrigin )

        unless isangle( startAngles )
            startAngles = getRenderAngles( ply )

        SetNW2Var( ply, "uTaunt-angles", startAngles )

        unless utaunt_collisions\GetBool!
            ply.m_iUnknownTauntCollisionGroup = ply\GetCollisionGroup!
            ply.m_bUnknownTauntAvoidPlayers = ply\GetAvoidPlayers!
            ply\SetAvoidPlayers( false )

        unless utaunt_allow_weapons\GetBool!
            weapon = ply\GetActiveWeapon!
            if weapon and IsValid( weapon )
                ply.m_sUnknownTauntWeapon = weapon\GetClass!
                ply\SetActiveWeapon!

        unless cycle
            cycle = 0

        SetNW2Var( ply, "uTaunt-start", CurTime! - ( cycle * duration ) )
        SetNW2Var( ply, "uTaunt-name", sequenceName )

        ply\AddVCDSequenceToGestureSlot( GESTURE_SLOT_CUSTOM, sequenceID, 0, true )

        if not noSound and ( GetInfo( ply, "utaunt_audio" ) == "1" or ply\IsBot! )
            soundPath = Run( "UnknownTauntSound", ply, sequenceName, cycle, duration, sequenceID )
            if soundPath ~= false
                if soundPath == nil or soundPath == true
                    soundPath = findSound( sequenceName )

                if soundPath
                    cSound = CreateSound( ply, soundPath )
                    ply.m_csUnknownTauntSound = cSound
                    cSound\ChangeVolume( 0, 0 )
                    cSound\SetDSP( 1 )
                    cSound\Play!

                    cSound\ChangeVolume( 1, 1 )

        Run( "PlayerStartTaunt", ply, ACT_GMOD_TAUNT_DANCE, duration )
        Run( "PlayerStartedUnknownTaunt", ply, sequenceName, duration )
        return true

    lib.Join = ( ply, otherPlayer ) ->
        sequenceName = GetNW2Var( otherPlayer, "uTaunt-name" )
        if sequenceName == nil
            return false

        sequenceID = LookupSequence( ply, sequenceName )
        if sequenceID < 1
            return false

        players = otherPlayer.m_tUnknownTauntPlayers
        if not isnumber( coopDances[ sequenceName ] ) or coopDances[ sequenceName ] < 1
            players[] = ply
            return lib.Start( ply, sequenceName, true, getCycle( otherPlayer, sequenceID ), true )

        danceName, danceID = match( sequenceName, "^([%a_]+_?)(%d+)$" )
        if danceName == nil or danceID == nil
            return false

        danceID = tonumber( danceID )
        if danceID == nil
            return false

        for index = 1, coopDances[ sequenceName ]
            if not isValidTauntingPlayer( players[ index ] ) or players[ index ] == ply
                players[ index ] = ply
                return lib.Start( ply, danceName .. ( danceID + index ), true, getCycle( otherPlayer, sequenceID ), true, otherPlayer\GetPos!, getRenderAngles( otherPlayer ) )

        return false

    do

        COLLISION_GROUP_PASSABLE_DOOR = COLLISION_GROUP_PASSABLE_DOOR
        :GetCollisionGroup = ENTITY
        :Crouching = PLAYER
        sequenceID = 0

        Add( "PlayerPostThink", addonName, ( ply ) ->
            sequenceName = GetNW2Var( ply, "uTaunt-name" )
            if sequenceName == nil
                return

            if not Alive( ply ) or Crouching( ply )
                forcedFinish( ply )
                return

            sequenceID = LookupSequence( ply, sequenceName )
            if sequenceID < 1
                forcedFinish( ply )
                return

            if GetModel( ply ) ~= ply.m_sUnknownTauntModel
                forcedFinish( ply )
                return

            cycle = getCycle( ply, sequenceID )
            if Run( "PlayerTauntThink", ply, sequenceName, cycle, sequenceID ) == false or cycle == 1
                lib.Finish( ply, false )
                return

            if utaunt_collisions\GetBool!
                return

            if GetCollisionGroup( ply ) == COLLISION_GROUP_PASSABLE_DOOR
                return

            SetCollisionGroup( ply, COLLISION_GROUP_PASSABLE_DOOR )
            return

        PRE_HOOK )

    concommand.Add "utaunt", ( ply, _, args ) ->
        if not ( ply and IsValid( ply ) and Alive( ply ) ) or isPlayingCTaunt( ply )
            return

        if isstring( args[ 1 ] )
            lib.Start( ply, args[ 1 ], false )
            return

    concommand.Add "utaunt_stop", ( ply ) ->
        if isPlayingTaunt( ply )
            lib.Finish( ply, false )

    Add "PlayerShouldTaunt", addonName, ( ply ) ->
        if isPlayingTaunt( ply ) or isPlayingCTaunt( ply )
            return false

    allowedActs = {
        [ ACT_GMOD_TAUNT_DANCE ]: true
        [ ACT_GMOD_TAUNT_ROBOT ]: true
        [ ACT_GMOD_TAUNT_CHEER ]: true
        [ ACT_GMOD_TAUNT_LAUGH ]: true
        [ ACT_GMOD_TAUNT_SALUTE ]: true
        [ ACT_GMOD_TAUNT_MUSCLE ]: true
        [ ACT_GMOD_TAUNT_PERSISTENCE ]: true

        [ ACT_GMOD_GESTURE_BOW ]: true
        [ ACT_GMOD_GESTURE_WAVE ]: true
        [ ACT_GMOD_GESTURE_AGREE ]: true
        [ ACT_GMOD_GESTURE_BECON ]: true
        [ ACT_GMOD_GESTURE_DISAGREE ]: true

        [ ACT_GMOD_GESTURE_RANGE_ZOMBIE ]: true
        [ ACT_GMOD_GESTURE_TAUNT_ZOMBIE ]: true
        [ ACT_GMOD_GESTURE_RANGE_ZOMBIE_SPECIAL ]: true

        [ ACT_GMOD_GESTURE_ITEM_GIVE ]: true
        [ ACT_GMOD_GESTURE_ITEM_DROP ]: true
        [ ACT_GMOD_GESTURE_ITEM_PLACE ]: true
        [ ACT_GMOD_GESTURE_ITEM_THROW ]: true

        [ ACT_SIGNAL_FORWARD ]: true
        [ ACT_SIGNAL_GROUP ]: true
        [ ACT_SIGNAL_HALT ]: true
    }

    Add "PlayerShouldUnknownTaunt", "Garry's Mod", ( ply, sequenceID ) ->
        if allowedActs[ ply\GetSequenceActivity( sequenceID ) ]
            return true

    Add( "PlayerFinishedTaunt", addonName, ( ply, sequenceName, isFinished ) ->
        if isFinished and GetInfo( ply, "utaunt_loop" ) == "1"
            lib.Start( ply, sequenceName, false )

    PRE_HOOK )

    Add( "PlayerButtonDown", addonName, ( ply, keyCode ) ->
        if keyCode == utaunt_menu_key\GetInt!
            ply\ConCommand( "utaunts " .. keyCode )
            return

    PRE_HOOK )

Add "PlayerSwitchWeapon", addonName, ( ply ) ->
    if isPlayingAnyTaunt( ply )
        if utaunt_allow_weapons\GetBool!
            return

        return true

do

    :SetRenderAngles = PLAYER

    Add( "UpdateAnimation", addonName, ( ply ) ->
        if isPlayingTaunt( ply )
            ply.m_dLastPlayingTaunt = CurTime!
            SetRenderAngles( ply, getRenderAngles( ply ) )

        elseif isPlayingCTaunt( ply )
            ply.m_dLastPlayingTaunt = CurTime!

        if ply.m_dLastPlayingTaunt == nil
            if ply.m_bIsPlayingTaunt == nil
                ply.m_bIsPlayingTaunt = false

            return

        if ( CurTime! - ply.m_dLastPlayingTaunt ) > 0.1
            ply.m_dLastPlayingTaunt = nil
            ply.m_bIsPlayingTaunt = false
            return

        ply.m_bIsPlayingTaunt = true

    PRE_HOOK )

do

    :ClearMovement, :SetButtons, :SetImpulse, :KeyDown, :RemoveKey = FindMetaTable( "CUserCmd" )
    IN_ATTACK, IN_ATTACK2, IN_DUCK, IN_JUMP = IN_ATTACK, IN_ATTACK2, IN_DUCK, IN_JUMP
    :band = bit

    buttons = 0

    Add( "StartCommand", addonName, ( ply, cmd ) ->
        unless isPlayingAnyTaunt( ply )
            return

        buttons = Run( "TauntStartCommand", ply, cmd, GetNW2Var( ply, "uTaunt-name", "" ) )
        unless isnumber( buttons )
            buttons = 0

        if KeyDown( cmd, IN_JUMP )
            RemoveKey( cmd, IN_JUMP )

            if isPlayingTaunt( ply ) and CLIENT and ply.m_bIsLocalPlayer
                RunConsoleCommand( "utaunt_stop" )

        if KeyDown( cmd, IN_DUCK )
            RemoveKey( cmd, IN_DUCK )

        unless utaunt_allow_movement\GetBool!
            ClearMovement( cmd )

        if utaunt_allow_attack\GetBool!
            if KeyDown( cmd, IN_ATTACK ) and band( buttons, IN_ATTACK ) == 0
                buttons = bor( buttons, IN_ATTACK )

            if KeyDown( cmd, IN_ATTACK2 ) and band( buttons, IN_ATTACK2 ) == 0
                buttons = bor( buttons, IN_ATTACK2 )

        SetButtons( cmd, buttons )
        SetImpulse( cmd, 0 )
        return

    PRE_HOOK )

unless CLIENT
    return

CreateClientConVar( "utaunt_loop", "0", true, true, "Enables looping for all taunts.", 0, 1 )

do

    utaunt_audio = CreateClientConVar( "utaunt_audio", "1", true, true, "Enables audio playback for taunts that support this feature.", 0, 1 )

    lib.IsAudioEnabled = ->
        return utaunt_audio\GetBool!

do

    utaunt_coop = CreateClientConVar( "utaunt_coop", "1", true, true, "If enabled player will automatically join/synchronize with dance of another player nearby.", 0, 1 )

    lib.IsCoopEnabled = ->
        return utaunt_coop\GetBool!

:GetPhrase = language

getPhrase = ( placeholder ) ->
    fulltext = GetPhrase( placeholder )
    if fulltext == placeholder and sub( placeholder, 1, 15 ) == "unknown_taunts."
        return GetPhrase( sub( placeholder, 16 ) )

    return fulltext

lib.GetPhrase = getPhrase

do

    ply = LocalPlayer!
    isInTaunt = false

    global IsInTaunt = ->
        return isInTaunt

    Add( "InitPostEntity", addonName, ->
        ply = LocalPlayer!
        ply.m_bIsLocalPlayer = true
        ply.m_bIsPlayingTaunt = false
    PRE_HOOK )

    Add( "Think", addonName, ->
        if ply and IsValid( ply )
            isInTaunt = ply.m_bIsPlayingTaunt
    PRE_HOOK )

    Add "HUDShouldDraw", addonName, ( name ) ->
        if isInTaunt and name == "CHudWeaponSelection"
            return false

do

    mins, maxs = Vector( -512, -512, 0 ), Vector( 512, 512, 512 )

    Add( "UnknownTauntSynced", addonName, ( entity ) ->
        mins[ 3 ] = entity\GetModelRenderBounds![ 3 ]
        entity\SetRenderBounds( mins, maxs )
        return
    PRE_HOOK )

Add( "PlayerFinishedTaunt", addonName, ( entity ) ->
    entity\SetRenderBounds( entity\GetModelRenderBounds! )
    return
PRE_HOOK )

do

    cycle = 0

    Add( "EntityNetworkedVarChanged", addonName, ( entity, key, oldValue, value ) ->
        unless IsValid( entity ) and entity\IsPlayer! and Alive( entity )
            return

        if key == "uTaunt-name"
            if value == nil
                if entity.m_bUsingUnknownTaunt
                    entity.m_bUsingUnknownTaunt = false
                    entity\AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
                    Run( "PlayerFinishedTaunt", entity, oldValue )

                return

            sequenceID = LookupSequence( entity, value )
            if sequenceID < 1
                return

            entity.m_bUsingUnknownTaunt = true

            cycle = getCycle( entity, sequenceID )
            entity\AddVCDSequenceToGestureSlot( GESTURE_SLOT_CUSTOM, sequenceID, cycle, true )
            Run( "UnknownTauntSynced", entity, value, cycle, sequenceID )
            return

        if key == "uTaunt-start"
            sequenceName = GetNW2Var( entity, "uTaunt-name" )
            if sequenceName == nil
                if entity.m_bUsingUnknownTaunt
                    entity.m_bUsingUnknownTaunt = false
                    entity\AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
                    Run( "PlayerFinishedTaunt", entity, oldValue )

                return

            sequenceID = LookupSequence( entity, sequenceName )
            if sequenceID < 1
                return

            entity.m_bUsingUnknownTaunt = true

            cycle = getCycle( entity, sequenceID, value )
            entity\AddVCDSequenceToGestureSlot( GESTURE_SLOT_CUSTOM, sequenceID, cycle, true )
            Run( "UnknownTauntSynced", entity, sequenceName, cycle, sequenceID )
            return

    PRE_HOOK )

    Add( "NotifyShouldTransmit", addonName, ( entity, shouldtransmit ) ->
        unless shouldtransmit and IsValid( entity ) and entity\IsPlayer! and Alive( entity )
            return

        sequenceName = GetNW2Var( entity, "uTaunt-name" )
        if sequenceName == nil
            if entity.m_bUsingUnknownTaunt
                entity.m_bUsingUnknownTaunt = false
                entity\AnimResetGestureSlot( GESTURE_SLOT_CUSTOM )
                Run( "PlayerFinishedTaunt", entity, oldValue )

            return

        sequenceID = LookupSequence( entity, sequenceName )
        if sequenceID < 1
            return

        entity.m_bUsingUnknownTaunt = true

        cycle = getCycle( entity, sequenceID )
        entity\AddVCDSequenceToGestureSlot( GESTURE_SLOT_CUSTOM, sequenceID, cycle, true )
        Run( "UnknownTauntSynced", entity, sequenceName, cycle, sequenceID )
        return

    PRE_HOOK )

toggleMenu = ( ply, keyCode ) ->
    if isPlayingCTaunt( ply )
        return false

    if keyCode ~= nil
        bind = input.LookupKeyBinding( keyCode )
        if bind ~= nil and #bind > 0
            return false

    panel = lib.Panel
    if panel and panel\IsValid!
        panel\Remove!
        return true

    if Run( "AllowTauntMenu", ply ) == false
        return false

    panel = vgui.Create( "uTaunt::Menu" )
    lib.Panel = panel
    panel\Setup( ply )
    return true

lib.ToggleMenu = toggleMenu

concommand.Add "utaunts", ( ply, _, args ) ->
    unless ply\Alive!
        return

    keyCode = args[ 1 ]
    if keyCode ~= nil and #keyCode > 0
        keyCode = tonumber( keyCode )

    toggleMenu( ply, keyCode )
    return

do

    commmands = { "taunt", "dance", "utaunt", "udance" }
    allowedChars = { "/": true, "!": true }

    Add "OnPlayerChat", addonName, ( ply, text, isTeam, isDead ) ->
        if isDead or isTeam or not ply.m_bIsLocalPlayer
            return

        text = lower( Trim( text ) )

        if allowedChars[ sub( text, 1, 1 ) ] == nil
            return

        text = sub( text, 2 )

        for command in *commmands
            if find( text, command, 1, false ) ~= nil
                toggleMenu( ply )
                return true

-- Garry's Mod
do

    acts = {
        ACT_GMOD_TAUNT_DANCE,
        ACT_GMOD_TAUNT_ROBOT,
        ACT_GMOD_TAUNT_CHEER,
        ACT_GMOD_TAUNT_LAUGH,
        ACT_GMOD_TAUNT_SALUTE,
        ACT_GMOD_TAUNT_MUSCLE,
        ACT_GMOD_TAUNT_PERSISTENCE,
        ACT_GMOD_GESTURE_BOW,
        ACT_GMOD_GESTURE_WAVE,
        ACT_GMOD_GESTURE_AGREE,
        ACT_GMOD_GESTURE_BECON,
        ACT_GMOD_GESTURE_DISAGREE,

        ACT_GMOD_GESTURE_RANGE_ZOMBIE,
        ACT_GMOD_GESTURE_TAUNT_ZOMBIE,
        ACT_GMOD_GESTURE_RANGE_ZOMBIE_SPECIAL,

        ACT_GMOD_GESTURE_ITEM_GIVE,
        ACT_GMOD_GESTURE_ITEM_DROP,
        ACT_GMOD_GESTURE_ITEM_PLACE,
        ACT_GMOD_GESTURE_ITEM_THROW,

        ACT_SIGNAL_FORWARD,
        ACT_SIGNAL_GROUP,
        ACT_SIGNAL_HALT
    }

    Add "UnknownTauntMenuSetup", "Garry's Mod", ( add ) =>
        sequences, sequencesCount = {}, 0
        for act in *acts
            sequenceID = @SelectWeightedSequence( act )
            if sequenceID < 1
                continue

            sequencesCount += 1
            sequences[ sequencesCount ] = @GetSequenceName( sequenceID )

        if sequencesCount == 0
            return

        add( "Garry's Mod:", sequences )
        return

do

    utaunt_menu_auto_close = CreateClientConVar( "utaunt_menu_auto_close", "0", true, false, "Automatically close the taunt menu when a taunt is selected.", 0, 1 )
    :DrawRect, :SetDrawColor = surface
    :floor, :Round = math

    PANEL = {}

    PANEL.Init = =>
        @SetTitle( "#unknown_taunts.menu.title" )
        @SetSize( ScreenScale( 128 ), 24 )
        @SetIcon( "icon16/user.png" )
        @MakePopup!
        @Center!

    PANEL.ClickSound = ->
        surface.PlaySound( "garrysmod/ui_click.wav" )

    PANEL.Setup = ( ply ) =>
        scrollPanel = @Add( "DScrollPanel" )
        @ScrollPanel = scrollPanel
        scrollPanel\Dock( FILL )

        scrollPanel.PerformLayout = ( _, width, height ) ->
            canvas = scrollPanel\GetCanvas!
            if canvas and canvas\IsValid!
                margin = ScreenScale( 2 )
                canvas\DockPadding( margin, 0, margin, margin )

            DScrollPanel.PerformLayout( scrollPanel, width, height )

        actions = scrollPanel\Add( "EditablePanel" )
        actions.Progress = 0
        actions\Dock( TOP )

        actions.PerformLayout = ->
            actions\SetTall( 32 )

        actions.Think = ->
            sequenceName = GetNW2Var( ply, "uTaunt-name" )
            if sequenceName == nil
                actions.Progress = 0
                return

            sequenceID = LookupSequence( ply, sequenceName )
            if sequenceID < 1
                actions.Progress = 0
                return

            actions.Progress = getCycle( ply, sequenceID )

        actions.Paint = ( _, width, height ) ->
            SetDrawColor( 150, 255, 50, 220 )
            DrawRect( 0, height - 2, width * actions.Progress, 2 )

        do

            button = actions\Add( "DButton" )
            button\SetText( "" )
            button\SetWide( 32 )
            button\Dock( RIGHT )
            button.Paint = ->

            button.UpdateIcon = ( state ) ->
                button\SetImage( state and "icon16/group.png" or "icon16/user.png" )

            button.UpdateIcon( cvars.Bool( "utaunt_coop" ) )

            button.DoClick = ->
                if cvars.Bool( "utaunt_coop" )
                    RunConsoleCommand( "utaunt_coop", "0" )
                    button.UpdateIcon( false )
                else
                    RunConsoleCommand( "utaunt_coop", "1" )
                    button.UpdateIcon( true )

                @ClickSound!

        do

            button = actions\Add( "DButton" )
            button\SetText( "" )
            button\SetWide( 32 )
            button\Dock( RIGHT )
            button.Paint = ->

            button.UpdateIcon = ( state ) ->
                button\SetImage( state and "icon16/sound.png" or "icon16/sound_mute.png" )

            button.UpdateIcon( cvars.Bool( "utaunt_audio" ) )

            button.DoClick = ->
                if cvars.Bool( "utaunt_audio" )
                    RunConsoleCommand( "utaunt_audio", "0" )
                    button.UpdateIcon( false )
                else
                    RunConsoleCommand( "utaunt_audio", "1" )
                    button.UpdateIcon( true )

                @ClickSound!

        do

            button = actions\Add( "DButton" )
            button\SetText( "" )
            button\SetWide( 32 )
            button\Dock( RIGHT )
            button.Paint = ->

            button.UpdateIcon = ( state ) ->
                button\SetImage( state and "icon16/control_repeat_blue.png" or "icon16/control_repeat.png" )

            button.UpdateIcon( cvars.Bool( "utaunt_loop" ) )

            button.DoClick = ->
                if cvars.Bool( "utaunt_loop" )
                    RunConsoleCommand( "utaunt_loop", "0" )
                    button.UpdateIcon( false )
                else
                    RunConsoleCommand( "utaunt_loop", "1" )
                    button.UpdateIcon( true )

                @ClickSound!

        do

            button = actions\Add( "DButton" )
            button\SetText( "" )
            button\SetWide( 32 )
            button\Dock( RIGHT )
            button.Paint = ->

            button.Think = ->
                state = isPlayingTaunt( ply )
                if button.State ~= state
                    button.State = state

                    if state
                        button\SetImage( "icon16/control_stop_blue.png" )
                    else
                        button\SetImage( "icon16/control_stop.png" )

            button.DoClick = ->
                if isPlayingTaunt( ply )
                    RunConsoleCommand( "utaunt_stop" )
                    @ClickSound!

        do

            label = actions\Add( "DLabel" )
            label.SequenceName = ""
            label\Dock( FILL )

            label.Think = ->
                unless isPlayingTaunt( ply )
                    if label.SequenceName ~= nil
                        label.SequenceName = nil
                        label\SetText( "#unknown_taunts.menu.none" )

                    return

                sequenceName = GetNW2Var( ply, "uTaunt-name" )
                if sequenceName == nil
                    if label.SequenceName ~= nil
                        label.SequenceName = nil
                        label\SetText( "#unknown_taunts.menu.none" )

                    return

                sequenceID = LookupSequence( ply, sequenceName )
                if sequenceID < 1
                    if label.SequenceName ~= nil
                        label.SequenceName = nil
                        label\SetText( "#unknown_taunts.menu.none" )

                    return

                if label.SequenceName ~= sequenceName
                    label.SequenceName = sequenceName
                    label.SequenceTitle = getPhrase( "unknown_taunts." .. sequenceName )

                duration = SequenceDuration( ply, sequenceID )
                timeRemaining = duration * getCycle( ply, sequenceID )
                if timeRemaining > 60
                    timeRemaining = Round( timeRemaining / 60, 1 ) .. "m"
                else
                    timeRemaining = floor( timeRemaining ) .. "s"

                if duration > 60
                    duration = Round( duration / 60, 1 ) .. "m"
                else
                    duration = floor( duration ) .. "s"

                str = label.SequenceTitle .. " ( " .. timeRemaining .. " / " .. duration .. " )"
                if str ~= label\GetText!
                    label\SetText( str )

        Run "UnknownTauntMenuSetup", ply, ( title, sequences ) ->
            if not istable( sequences )
                return

            length = #sequences
            if length == 0
                return

            for index = 1, length
                if Run( "AllowUnknownTaunt", ply, sequences[ index ], title ) == false
                    sequences[ index ] = false

            length = #sequences
            if length == 0
                return

            combo = @[ title ]
            unless combo and combo\IsValid!
                label = scrollPanel\Add( "DLabel" )
                label\SetText( title )
                label\Dock( TOP )

                combo = scrollPanel\Add( "DComboBox" )
                @[ title ] = combo

                combo\SetText( "#unknown_taunts.menu.select" )
                combo\Dock( TOP )

                combo.OnSelect = ( _, __, ___, name ) ->
                    RunConsoleCommand( "utaunt", name )

                    if utaunt_menu_auto_close\GetBool!
                        @Close!
                        return

                    combo\SetText( "#unknown_taunts.menu.select" )

            for index = 1, length
                if sequences[ index ] ~= false
                    combo\AddChoice( getPhrase( "unknown_taunts." .. sequences[ index ] ), sequences[ index ] )

    PANEL.PerformLayout = ( width, height ) =>
        scrollPanel = @ScrollPanel
        if scrollPanel and scrollPanel\IsValid!
            height = 0
            for pnl in *scrollPanel\GetCanvas!\GetChildren!
                height += pnl\GetTall!

            if height == 0
                @Remove!
                return

            @SetTall( math.min( height + 48, ScrH! * 0.5 ) )

        DFrame.PerformLayout( @, width, height )

    PANEL.Paint = ( width, height ) =>
        SetDrawColor( 50, 50, 50, 220 )
        DrawRect( 0, 0, width, height )

    vgui.Register( "uTaunt::Menu", PANEL, "DFrame" )

do

    HSVToColor = HSVToColor
    :Round = math
    MsgC = MsgC

    concommand.Add "utaunt_list", ( ply, _, args ) ->
        modelSequences = GetSequenceList( ply )
        allowAll = args[ 1 ] == "1"
        sequences, count = {}, 0

        for index = 1, #modelSequences
            sequenceName = modelSequences[ index ]
            if not allowAll and Run( "AllowUnknownTaunt", ply, sequenceName, "Sequences" ) == false
                continue

            placeholder = "unknown_taunts." .. sequenceName
            fulltext = GetPhrase( placeholder )
            if not allowAll and fulltext == placeholder
                continue

            count += 1

            duration = SequenceDuration( ply, index )
            if duration > 60
                sequences[ count ] = sequenceName .. " (" .. Round( duration / 60, 1 ) .. " minutes) - " .. fulltext
                continue

            sequences[ count ] = sequenceName .. " (" .. Round( duration, 2 ) .. " seconds) - " .. fulltext

        if count == 0
            MsgC( "No sequences found.\n" )
            return

        MsgC( "Sequences:\n" )
        for index = 1, count
            MsgC( index .. ". ", HSVToColor( ( 180 + index ) % 360, 1, 1 ), sequences[ index ], "\n" )

list.Set "DesktopWindows", "utaunt-menu", {
    title: "uTaunt"
    icon: "icon16/color_swatch.png"
    init: ( icon, window ) ->
        if window and window\IsValid!
            window\Remove!

        icon.DoClick = ->
            RunConsoleCommand( "utaunts" )

        RunConsoleCommand( "utaunts" )
}
